{"version":3,"sources":["helpers/animation.js","components/valuecell.js","components/backgroundcell.js","logic/gamelogic.js","components/board.js","components/game.js","index.js"],"names":["AnimationHelper","duration","this","startTime","animationDone","currentTime","elapsed","ratio","Math","min","ValueAnimator","fromValue","toValue","reverse","valDiff","currentVal","animationHelper","callback","updateCallback","animationProgRatio","getTimeRatio","isDone","reset","from","SequentialAnimator","animationList","currentAnimationIndex","length","currentAnim","update","isCompleted","animator","push","every","anim","ValueCell","props","divRef","React","createRef","animate","bind","resetAnimationStatus","state","translationX","translationY","scaleFactor","recycled","styles","gridRow","cell","row","gridColumn","col","isMoving","classesArray","val","isGettingMerged","classes","join","className","style","ref","prevProps","animationRequestId","animation","prepareAnimation","window","requestAnimationFrame","cancelAnimationFrame","time","animationDoneCallback","totalAnimator","xCellsDelta","colDestination","yCellsDelta","rowDestination","borderPx","Number","parseInt","getComputedStyle","current","getPropertyValue","trim","replace","boundingBox","getBoundingClientRect","cellWidth","width","cellHeight","height","xAxisMove","delta","cellsDelta","translationDuration","abs","TRANSLATION_1_CELL_DURATION","translationAnimator","setUpdatedValueCallback","xVal","yVal","setState","addAnimator","isMergingInto","scaleAnimator","SCALING_DURATION","Component","BackgroundCell","MoveDirection","GameStatus","getRandomInt","max","floor","random","Cell","nextVal","mergedInto","mergingInto","cellIdentifier","nextIdentifierAvailable","amount","direction","GameBoard","rows","columns","cells","ROWS","COLUMNS","Array","fill","map","initializeGrid","cellsCopy","copy","nonEmptyCells","forEach","isEmpty","inPlace","board","flatCells","flat","applyMoveAndClear","n","value","emptyCells","i","cIndex","emptyCell","splice","moveDirection","lines","line","slice","prevNonZeroCell","j","moveBy","markGettingMerged","markMerging","diffs","reduce","acc","winConditionThreshold","hasWon","some","possibleMoves","hasMoveAvailable","move","cellsArray","Board","handleKeyDown","handleAnimationDone","gameBoard","spawnCells","acceptInput","expectedAnimations","boxes","newBoard","applyMoves","checkGameStatus","keyevent","moveDir","oldBoard","keyCode","document","addEventListener","registerResetCallback","removeEventListener","bgCells","generateBackgroundCells","valueCells","getNonEmptyCells","c","Header","options","onGridSizeChanged","onNewGameClicked","GridSizeSelector","onChange","opt","optString","event","target","blur","action","htmlFor","id","getOptions","NewGameButton","onClick","Game","DEFAULT_ROWS","DEFAULT_COLS","gridOptions","handleGridResize","handleNewGameClicked","setNewGameHandler","newSize","handler","newGameHandler","ReactDOM","render","getElementById"],"mappings":"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","file":"static/js/main.829014a8.chunk.js","sourcesContent":["class AnimationHelper {\r\n    constructor(duration) {\r\n        this.startTime = null;\r\n        this.duration = duration;\r\n        this.animationDone = false;\r\n    }\r\n\r\n    getTimeRatio(currentTime) {\r\n        if (this.startTime === null) {\r\n            this.startTime = currentTime;\r\n            return 0.0;\r\n        }\r\n\r\n        let elapsed = currentTime - this.startTime;\r\n        let ratio = Math.min(1.0, (elapsed / this.duration));\r\n\r\n        if (ratio >= 1)\r\n            this.animationDone = true;\r\n\r\n        return ratio;\r\n    }\r\n\r\n    isDone() {\r\n        return this.animationDone;\r\n    }\r\n\r\n    reset(startTime) {\r\n        this.startTime = startTime;\r\n        this.animationDone = false;\r\n    }\r\n}\r\n\r\nclass ValueAnimator {\r\n    constructor(fromValue, toValue, duration, reverse = false) {\r\n        this.fromValue = fromValue;\r\n        this.toValue = toValue;\r\n        this.valDiff = toValue - fromValue;\r\n        this.currentVal = fromValue;\r\n        this.reverse = reverse;\r\n        this.animationHelper = new AnimationHelper(duration);\r\n    }\r\n\r\n    setUpdatedValueCallback(callback) {\r\n        this.updateCallback = callback;\r\n        return this;\r\n    }\r\n\r\n    update(currentTime) {\r\n        let animationProgRatio = this.animationHelper.getTimeRatio(currentTime);\r\n        this.currentVal = this.fromValue + (this.valDiff * animationProgRatio);\r\n        if (this.updateCallback)\r\n            this.updateCallback(this.currentVal);\r\n        if (this.animationHelper.isDone() && this.reverse) {\r\n            this.reverse = false;\r\n            this.animationHelper.reset(currentTime);\r\n            let from = this.fromValue;\r\n            this.fromValue = this.toValue;\r\n            this.toValue = from;\r\n            this.valDiff = this.toValue - this.fromValue;\r\n            this.currentVal = this.fromValue;\r\n        }\r\n    }\r\n\r\n    getCurrentValue() {\r\n        return this.currentVal;\r\n    }\r\n\r\n    isCompleted() {\r\n        return this.animationHelper.isDone();\r\n    }\r\n}\r\n\r\nclass SequentialAnimator {\r\n\r\n    constructor() {\r\n        this.animationList = [];\r\n        this.currentAnimationIndex = 0;\r\n    }\r\n\r\n    update(currentTime) {\r\n        if (this.currentAnimationIndex < this.animationList.length) {\r\n            let currentAnim = this.animationList[this.currentAnimationIndex];\r\n            currentAnim.update(currentTime);\r\n            if (currentAnim.isCompleted())\r\n                this.currentAnimationIndex++;\r\n        }\r\n    }\r\n\r\n    addAnimator(animator) {\r\n        this.animationList.push(animator);\r\n    }\r\n\r\n    isCompleted() {\r\n        return this.animationList.every(anim => anim.isCompleted());\r\n    }\r\n\r\n}\r\n\r\nexport { ValueAnimator, SequentialAnimator};","import React from 'react';\r\nimport { SequentialAnimator, ValueAnimator } from '../helpers/animation';\r\n\r\nclass ValueCell extends React.Component {\r\n\r\n    static TRANSLATION_1_CELL_DURATION = 100;\r\n    static SCALING_DURATION = 100;\r\n\r\n    constructor(props) {\r\n        super(props);\r\n        this.divRef = React.createRef();\r\n        this.animate = this.animate.bind(this);\r\n        this.resetAnimationStatus();\r\n        this.state = { translationX: 0, translationY: 0, scaleFactor: 100 };\r\n        this.recycled = false;\r\n    }\r\n\r\n    render() {\r\n        let styles = {\r\n            gridRow: this.props.cell.row + 1,\r\n            gridColumn: this.props.cell.col + 1,\r\n        };\r\n\r\n        if (this.props.cell.isMoving()) {\r\n            styles['transform'] = `translate(${this.state.translationX}px, ${this.state.translationY}px) scale(${this.state.scaleFactor}%)`\r\n        }\r\n\r\n        let classesArray = [];\r\n        classesArray.push('value-cell');\r\n        classesArray.push(`value-${Math.min(2048, this.props.cell.val)}`);\r\n        classesArray.push(this.props.cell.isGettingMerged() ? 'value-cell-merged' : 'value-cell-top');\r\n        if(!this.recycled) {\r\n            classesArray.push('value-cell-pop-in')\r\n            this.recycled = true;\r\n        }\r\n\r\n        let classes = classesArray.join(' ');\r\n\r\n        return (\r\n            <div className={classes} style={styles} ref={this.divRef} >\r\n                {this.props.cell.val}\r\n            </div>\r\n        );\r\n    }\r\n\r\n    componentDidUpdate(prevProps) {\r\n        if (prevProps.cell.isMoving() && !this.props.cell.isMoving())\r\n            this.resetAnimationStatus();\r\n\r\n        if (this.props.cell.isMoving() && !this.animationDone && this.animationRequestId === 0) {\r\n            this.animation = this.prepareAnimation();\r\n            this.animationRequestId = window.requestAnimationFrame(this.animate);\r\n        }\r\n    }\r\n\r\n    componentWillUnmount() {\r\n        if (this.animationRequestId !== 0)\r\n            window.cancelAnimationFrame(this.animationRequestId);\r\n    }\r\n\r\n    animate(time) {\r\n        this.animation.update(time);\r\n\r\n        if (!this.animation.isCompleted())\r\n            this.animationRequestId = window.requestAnimationFrame(this.animate);\r\n        else {\r\n            this.animation = null;\r\n            this.animationDone = true;\r\n            this.animationRequestId = 0;\r\n            this.props.animationDoneCallback();\r\n        }\r\n    }\r\n\r\n    prepareAnimation() {\r\n        let totalAnimator = new SequentialAnimator();\r\n\r\n        // Translation\r\n        let xCellsDelta = this.props.cell.colDestination - this.props.cell.col;\r\n        let yCellsDelta = this.props.cell.rowDestination - this.props.cell.row;\r\n        let borderPx = Number.parseInt(getComputedStyle(this.divRef.current).getPropertyValue('--grid-border').trim().replace(\"px\", \"\"));\r\n        let boundingBox = this.divRef.current.getBoundingClientRect();\r\n        let cellWidth = boundingBox.width;\r\n        let cellHeight = boundingBox.height;\r\n        let xAxisMove = xCellsDelta !== 0;\r\n        let delta = xAxisMove ? (xCellsDelta * cellWidth) + (borderPx * xCellsDelta) : (yCellsDelta * cellHeight) + (borderPx * yCellsDelta);\r\n        let cellsDelta = xAxisMove ? xCellsDelta : yCellsDelta;\r\n        let translationDuration = Math.abs(cellsDelta) * ValueCell.TRANSLATION_1_CELL_DURATION;\r\n        let translationAnimator = new ValueAnimator(0, delta, translationDuration).setUpdatedValueCallback(val => {\r\n            let xVal = xCellsDelta !== 0 ? val : 0;\r\n            let yVal = yCellsDelta !== 0 ? val : 0;\r\n            this.setState({ translationX: xVal, translationY: yVal });\r\n        });\r\n        totalAnimator.addAnimator(translationAnimator);\r\n\r\n        // Merge animation, only if cell is merging\r\n        if (this.props.cell.isMergingInto()) {\r\n            let scaleAnimator = new ValueAnimator(100, 115, ValueCell.SCALING_DURATION, true).setUpdatedValueCallback(val => {\r\n                this.setState({ scaleFactor: val });\r\n            });\r\n            totalAnimator.addAnimator(scaleAnimator);\r\n        }\r\n\r\n        return totalAnimator;\r\n    }\r\n\r\n    resetAnimationStatus() {\r\n        this.animation = null;\r\n        this.animationDone = false;\r\n        this.animationRequestId = 0;\r\n    }\r\n}\r\n\r\nexport { ValueCell as default };","import React from 'react';\r\n\r\nclass BackgroundCell extends React.Component {\r\n    render() {\r\n        return (\r\n            <div className=\"bg-cell\" style={{ gridRow: this.props.row + 1, gridColumn: this.props.col + 1 }} />\r\n        );\r\n    }\r\n}\r\n\r\nexport { BackgroundCell as default };","const MoveDirection = {\r\n    UP: 0,\r\n    RIGHT: 1,\r\n    DOWN: 2,\r\n    LEFT: 3\r\n}\r\n\r\nconst GameStatus = {\r\n    WON: 0,\r\n    LOST: 1,\r\n    YET_UNDEFINED: 2\r\n}\r\n\r\nfunction getRandomInt(max) {\r\n    return Math.floor(Math.random() * max);\r\n}\r\n\r\nclass Cell {\r\n\r\n    static nextIdentifierAvailable = 1;\r\n\r\n    constructor(row, col, val = 0, nextVal = 0, rowDestination = null, colDestination = null, mergedInto = false, mergingInto=false, cellIdentifier = null) {\r\n        this.row = row;\r\n        this.col = col;\r\n        this.val = val;\r\n        this.nextVal = nextVal;\r\n        this.rowDestination = rowDestination;\r\n        this.colDestination = colDestination;\r\n        this.mergedInto = mergedInto;\r\n        this.mergingInto = mergingInto;\r\n        this.cellIdentifier = cellIdentifier || Cell.nextIdentifierAvailable++;\r\n    }\r\n\r\n    isEmpty() {\r\n        return this.val === 0;\r\n    }\r\n\r\n    applyMoveAndClear() {\r\n        if (this.isMoving()) {\r\n            this.row = this.rowDestination;\r\n            this.col = this.colDestination;\r\n            if (this.nextVal !== 0) {\r\n                this.val = this.nextVal;\r\n                this.nextVal = 0;\r\n            }\r\n            this.rowDestination = null;\r\n            this.colDestination = null;\r\n            this.mergingInto = false;\r\n            this.mergedInto = false;\r\n        }\r\n    }\r\n\r\n    moveBy(amount, direction) {\r\n        if (this.rowDestination === null)\r\n            this.rowDestination = this.row;\r\n        if (this.colDestination === null)\r\n            this.colDestination = this.col;\r\n\r\n        switch (direction) {\r\n            case MoveDirection.UP: this.rowDestination = this.rowDestination - amount; break;\r\n            case MoveDirection.DOWN: this.rowDestination = this.rowDestination + amount; break;\r\n            case MoveDirection.LEFT: this.colDestination = this.colDestination - amount; break;\r\n            case MoveDirection.RIGHT: this.colDestination = this.colDestination + amount; break;\r\n            default: return;\r\n        }\r\n    }\r\n\r\n    isMoving() {\r\n        return this.rowDestination !== null || this.colDestination !== null;\r\n    }\r\n\r\n    markGettingMerged() {\r\n        this.mergedInto = true;\r\n    }\r\n\r\n    markMerging() {\r\n        this.mergingInto = true;\r\n    }\r\n\r\n    isGettingMerged() {\r\n        return this.mergedInto;\r\n    }\r\n\r\n    isMergingInto() {\r\n        return this.mergingInto;\r\n    }\r\n\r\n    copy() {\r\n        return new Cell(this.row, this.col, this.val, this.nextVal, this.rowDestination, this.colDestination, this.mergedInto, this.mergingInto, this.cellIdentifier);\r\n    }\r\n}\r\n\r\nclass GameBoard {\r\n    constructor(rows, columns, cells) {\r\n        this.ROWS = rows;\r\n        this.COLUMNS = columns;\r\n        if (cells)\r\n            this.cells = cells;\r\n        else {\r\n            this.cells = Array(rows).fill().map(() => Array(columns).fill());\r\n            GameBoard.initializeGrid(this.cells, rows, columns);\r\n        }\r\n    }\r\n\r\n    copy() {\r\n        let cellsCopy = this.cells.map((row) => row.map(cell => cell.copy()));\r\n        return new GameBoard(this.ROWS, this.COLUMNS, cellsCopy);\r\n    }\r\n\r\n    static initializeGrid(cellsArray, rows, columns) {\r\n        for (let i = 0; i < rows; i++)\r\n            for (let j = 0; j < columns; j++)\r\n                cellsArray[i][j] = new Cell(i, j);\r\n\r\n        return cellsArray;\r\n    }\r\n\r\n    getNonEmptyCells() {\r\n        let nonEmptyCells = [];\r\n\r\n        this.cells.forEach(row => {\r\n            row.forEach(cell => {\r\n                if (!cell.isEmpty())\r\n                    nonEmptyCells.push(cell);\r\n            });\r\n        });\r\n\r\n        return nonEmptyCells;\r\n    }\r\n\r\n    /**\r\n     * \r\n     * @param {boolean} inPlace specify if doing the operation in place or return a new board with the pending moves applied\r\n     * @returns the board with the moves applied, or a copy of the board with the moves applied if inPlace=false\r\n     */\r\n\r\n    applyMoves(inPlace = false) {\r\n        let board = inPlace ? this : this.copy();\r\n\r\n        let flatCells = board.cells.flat();\r\n\r\n        GameBoard.initializeGrid(board.cells, board.ROWS, board.COLUMNS);\r\n\r\n        flatCells.forEach(cell => {\r\n            if (cell.isMoving()) {\r\n                if (!cell.isGettingMerged()) {\r\n                    board.cells[cell.rowDestination][cell.colDestination] = cell;\r\n                    cell.applyMoveAndClear();\r\n                }\r\n            } else {\r\n                if (!cell.isEmpty() && !cell.isGettingMerged())\r\n                    board.cells[cell.row][cell.col] = cell;\r\n            }\r\n        });\r\n\r\n        return board;\r\n    }\r\n\r\n\r\n    /**\r\n     * \r\n     * @param {number} n the number of cells to spawn\r\n     * @param {number} value the value of the cells spawned\r\n     * @param {boolean} inPlace specify if doing the operation in place or return a board copy with the spawned cells\r\n     * @returns the board ref itself or the new board with the spawned cells, the same board ref if it couldn't spawn any even if inPlace=false\r\n     */\r\n\r\n    spawnCells(n, value = 2, inPlace = false) {\r\n        let board = inPlace ? this : this.copy(); \r\n        let emptyCells = [];\r\n\r\n        board.cells.forEach(row => {\r\n            row.forEach(cell => {\r\n                if (cell.isEmpty())\r\n                    emptyCells.push(cell);\r\n            });\r\n        });\r\n\r\n\r\n        if (emptyCells.length < n)\r\n            return this;\r\n\r\n        for (let i = 0; i < n; i++) {\r\n            let cIndex = getRandomInt(emptyCells.length);\r\n            let emptyCell = emptyCells[cIndex];\r\n            board.cells[emptyCell.row][emptyCell.col].val = value;\r\n            emptyCells.splice(cIndex, 1);\r\n        }\r\n\r\n        return board;\r\n    }\r\n\r\n    /**\r\n     * \r\n     * @param {MoveDirection} moveDirection the direction you want the tiles to go\r\n     * @param {boolean} inPlace specify if doing the operation in place or return a board copy with the diffs applied\r\n     * @returns a new board with the tiles moved if any changes happened, otherwise the same board ref, even if inPlace=false\r\n     */\r\n\r\n    move(moveDirection, inPlace = false) {\r\n        let board = inPlace ? this : this.copy();\r\n        let lines = [];\r\n\r\n        switch (moveDirection) {\r\n            case MoveDirection.UP:\r\n                for (let col = 0; col < board.COLUMNS; col++) {\r\n                    let line = [];\r\n                    for (let row = 0; row < board.ROWS; row++)\r\n                        line.push(board.cells[row][col]);\r\n                    lines.push(line);\r\n                }\r\n                break;\r\n            case MoveDirection.DOWN:\r\n                for (let col = 0; col < board.COLUMNS; col++) {\r\n                    let line = [];\r\n                    for (let row = board.ROWS - 1; row >= 0; row--)\r\n                        line.push(board.cells[row][col]);\r\n                    lines.push(line);\r\n                }\r\n                break;\r\n            case MoveDirection.LEFT:\r\n                lines = board.cells.map(row => row.slice());\r\n                break;\r\n            case MoveDirection.RIGHT:\r\n                lines = board.cells.map(row => row.slice().reverse());\r\n                break;\r\n            default: return;\r\n        }\r\n\r\n        lines.forEach(line => {\r\n            let prevNonZeroCell = null;\r\n            for (let i = 0; i < line.length; i++) {\r\n                let cell = line[i];\r\n                if (cell.isEmpty()) {\r\n                    for (let j = i + 1; j < line.length; j++)\r\n                        if (!line[j].isEmpty())\r\n                            line[j].moveBy(1, moveDirection);\r\n                } else {\r\n                    if (prevNonZeroCell === null) {\r\n                        prevNonZeroCell = cell;\r\n                    } else {\r\n                        if (prevNonZeroCell.val === cell.val) {\r\n                            prevNonZeroCell.markGettingMerged();\r\n                            cell.nextVal = cell.val * 2;\r\n                            cell.markMerging();\r\n\r\n                            for (let j = i; j < line.length; j++) {\r\n                                if (!line[j].isEmpty())\r\n                                    line[j].moveBy(1, moveDirection);\r\n                            }\r\n\r\n                            prevNonZeroCell = null;\r\n                        } else {\r\n                            prevNonZeroCell = cell;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        });\r\n\r\n        let diffs = board.cells.flat().reduce((acc, cell) => acc + (cell.isMoving() ? 1 : 0), 0);\r\n\r\n        if (!diffs)\r\n            return this;\r\n\r\n        return board;\r\n    }\r\n\r\n    /**\r\n     * \r\n     * @param {number} winConditionThreshold the win condition magic number, 2048 normally\r\n     * @returns the current game status [GameStatus.WON, GameStatus.LOST, GameStatus.YET_UNDEFINED]\r\n     */\r\n\r\n    checkGameStatus(winConditionThreshold=2048) {\r\n        let cells = this.cells.flat();\r\n        \r\n        let hasWon = cells.some(cell => cell.val >= winConditionThreshold);\r\n        if(hasWon) \r\n            return GameStatus.WON;\r\n        \r\n        let possibleMoves = [MoveDirection.UP, MoveDirection.DOWN, MoveDirection.LEFT, MoveDirection.RIGHT];\r\n        let hasMoveAvailable = possibleMoves.some(move => this.move(move) !== this);\r\n        \r\n        if(hasMoveAvailable)\r\n            return GameStatus.YET_UNDEFINED;\r\n        else\r\n            return GameStatus.LOST;\r\n    }\r\n\r\n    toString() {\r\n        return this.cells.map(row => row.map(cell => cell.val).join(' ')).join('\\r\\n');\r\n    }\r\n}\r\n\r\nexport { GameStatus, MoveDirection, Cell, GameBoard }","import React from 'react';\r\nimport ValueCell from './valuecell'\r\nimport BackgroundCell from './backgroundcell';\r\nimport { MoveDirection, GameBoard, GameStatus } from '../logic/gamelogic';\r\n\r\nclass Board extends React.Component {\r\n    constructor(props) {\r\n        super(props);\r\n        this.handleKeyDown = this.handleKeyDown.bind(this);\r\n        this.handleAnimationDone = this.handleAnimationDone.bind(this);\r\n        this.reset = this.reset.bind(this);\r\n\r\n        let gameBoard = new GameBoard(props.rows, props.columns).spawnCells(1, 2, true);\r\n        this.state = { board: gameBoard };\r\n\r\n        this.acceptInput = true;\r\n        this.expectedAnimations = -1;\r\n    }\r\n\r\n    reset() {\r\n        let gameBoard = new GameBoard(this.props.rows, this.props.columns).spawnCells(1, 2, true);\r\n        this.acceptInput = true;\r\n        this.expectedAnimations = -1;\r\n        this.setState({\r\n            board: gameBoard\r\n        });\r\n    }\r\n\r\n    generateBackgroundCells(rows, columns) {\r\n        let boxes = [];\r\n\r\n        for (let i = 0; i < rows; i++)\r\n            for (let j = 0; j < columns; j++)\r\n                boxes.push(<BackgroundCell key={i * columns + j} row={i} col={j} />);\r\n\r\n        return boxes;\r\n    }\r\n\r\n    handleAnimationDone() {\r\n        this.expectedAnimations -= 1;\r\n\r\n        if (this.expectedAnimations === 0) {\r\n            let newBoard = this.state.board.applyMoves().spawnCells(1, 2 , true);\r\n            this.acceptInput = true;\r\n            let gameStatus = newBoard.checkGameStatus();\r\n\r\n            if(gameStatus === GameStatus.WON) {\r\n                // TODO: Implement what to do if game is won\r\n            } else if(gameStatus === GameStatus.LOST) {\r\n                // TODO: Implement what to do on game lost\r\n            }\r\n\r\n            this.setState({ board: newBoard });\r\n        }\r\n    }\r\n\r\n    handleKeyDown(keyevent) {\r\n        if (!this.acceptInput)\r\n            return;\r\n\r\n        let oldBoard = this.state.board;\r\n        let newBoard;\r\n        let moveDir;\r\n\r\n        switch (keyevent.keyCode) {\r\n            case 40: moveDir = MoveDirection.DOWN; break;\r\n            case 39: moveDir = MoveDirection.RIGHT; break;\r\n            case 38: moveDir = MoveDirection.UP; break;\r\n            case 37: moveDir = MoveDirection.LEFT; break;\r\n            default: return;\r\n        }\r\n\r\n        newBoard = oldBoard.move(moveDir, false);\r\n        if (newBoard !== oldBoard) {\r\n            this.acceptInput = false;\r\n            this.expectedAnimations = newBoard.cells.flat().reduce((acc, cell) => acc + (cell.isMoving() ? 1 : 0), 0);\r\n            this.setState({ board: newBoard });\r\n        }\r\n    }\r\n\r\n    componentDidMount() {\r\n        document.addEventListener(\"keydown\", this.handleKeyDown);\r\n        this.props.registerResetCallback(this.reset);\r\n    }\r\n\r\n    componentWillUnmount() {\r\n        document.removeEventListener(\"keydown\", this.handleKeyDown);\r\n    }\r\n\r\n    render() {\r\n        const bgCells = this.generateBackgroundCells(this.props.rows, this.props.columns);\r\n        const nonEmptyCells = this.state.board.getNonEmptyCells();\r\n        const valueCells = nonEmptyCells.map((c) => {\r\n            return <ValueCell key={c.cellIdentifier} cell={c} animationDoneCallback={this.handleAnimationDone} />\r\n        });\r\n\r\n        return (\r\n            <div className=\"gamegrid\" style={{'--grid-rows': this.props.rows, '--grid-cols': this.props.columns}}>\r\n                {bgCells}\r\n                {valueCells}\r\n            </div>\r\n        );\r\n    }\r\n}\r\n\r\nexport { Board as default };\r\n","import React from 'react';\r\nimport Board from './board'\r\n\r\nclass Header extends React.Component {\r\n    render() {\r\n        return (\r\n            <>\r\n                <div className=\"header-line-1\">\r\n                    <h1> 2048 </h1>\r\n                </div>\r\n                <div className=\"header-line-2\">\r\n                    <GridSizeSelector options={this.props.options} onGridSizeChanged={this.props.onGridSizeChanged} />\r\n                    <NewGameButton onNewGameClicked={this.props.onNewGameClicked}/>\r\n                </div>\r\n            </>\r\n        );\r\n    }\r\n}\r\n\r\nclass GridSizeSelector extends React.Component {\r\n\r\n    constructor(props) {\r\n        super(props);\r\n        this.onChange = this.onChange.bind(this);\r\n    }\r\n\r\n    getOptions() {\r\n        let options = [];\r\n        this.props.options.forEach(opt => {\r\n            const optString = `${opt} x ${opt}`;\r\n            options.push(<option key={opt} value={opt}>{optString}</option>)\r\n        });\r\n        return options;\r\n    }\r\n\r\n    onChange(event) {\r\n        event.target.blur();\r\n        this.props.onGridSizeChanged(parseInt(event.target.value));\r\n    }\r\n\r\n    render() {\r\n        return (\r\n            <form action=\"#\">\r\n                <label htmlFor=\"sizeselector\">Grid size: </label>\r\n                <select id=\"sizeselector\" onChange={this.onChange}>\r\n                    {this.getOptions()}\r\n                </select>\r\n            </form>\r\n        );\r\n    }\r\n}\r\n\r\nclass NewGameButton extends React.Component {\r\n    render() {\r\n        return (\r\n            <button className=\"new-game-btn\" onClick={this.props.onNewGameClicked}>New Game</button>\r\n        );\r\n    }\r\n}\r\n\r\nclass Game extends React.Component {\r\n\r\n    static DEFAULT_ROWS = 4;\r\n    static DEFAULT_COLS = 4;\r\n\r\n    constructor(props) {\r\n        super();\r\n        this.state = {\r\n            rows: Game.DEFAULT_ROWS,\r\n            columns: Game.DEFAULT_COLS\r\n        };\r\n        this.gridOptions = []\r\n        for (let i = 4; i <= 8; i++)\r\n            this.gridOptions.push(i);\r\n\r\n        this.handleGridResize = this.handleGridResize.bind(this);\r\n        this.handleNewGameClicked = this.handleNewGameClicked.bind(this);\r\n        this.setNewGameHandler = this.setNewGameHandler.bind(this);\r\n    }\r\n\r\n    handleGridResize(newSize) {\r\n        this.setState({\r\n            rows: newSize,\r\n            columns: newSize\r\n        });\r\n    }\r\n\r\n    setNewGameHandler(handler) {\r\n        this.newGameHandler = handler;\r\n    }\r\n\r\n    handleNewGameClicked() {\r\n        if(this.newGameHandler)\r\n            this.newGameHandler();\r\n    }\r\n\r\n    render() {\r\n        return (\r\n            <div className=\"gamecontainer\">\r\n                <Header options={this.gridOptions} onGridSizeChanged={this.handleGridResize} onNewGameClicked={this.handleNewGameClicked}/>\r\n                <Board key={this.state.rows * this.state.columns} rows={this.state.rows} columns={this.state.columns} registerResetCallback={this.setNewGameHandler}/>\r\n            </div>\r\n        );\r\n    }\r\n}\r\n\r\nexport { Game as default };","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport Game from './components/game'\r\nimport './css/index.css';\r\n\r\nReactDOM.render(\r\n    <Game/>,\r\n    document.getElementById('root')\r\n);"],"sourceRoot":""}