{"version":3,"sources":["helpers/animation.js","components/valuecell.js","components/backgroundcell.js","logic/gamelogic.js","components/board.js","components/game.js","index.js"],"names":["AnimationHelper","duration","this","startTime","animationDone","currentTime","elapsed","ratio","Math","min","ValueAnimator","fromValue","toValue","reverse","valDiff","currentVal","animationHelper","callback","updateCallback","animationProgRatio","getTimeRatio","isDone","reset","from","SequentialAnimator","animationList","currentAnimationIndex","length","currentAnim","update","isCompleted","animator","push","every","anim","ValueCell","props","divRef","React","createRef","animate","bind","resetAnimationStatus","state","translationX","translationY","scaleFactor","recycled","styles","gridRow","cell","row","gridColumn","col","isMoving","classesArray","val","isGettingMerged","classes","join","className","style","ref","prevProps","animationRequestId","animation","prepareAnimation","window","requestAnimationFrame","cancelAnimationFrame","time","animationDoneCallback","totalAnimator","xCellsDelta","colDestination","yCellsDelta","rowDestination","borderPx","Number","parseInt","getComputedStyle","current","getPropertyValue","trim","replace","boundingBox","getBoundingClientRect","cellWidth","width","cellHeight","height","xAxisMove","delta","cellsDelta","translationDuration","abs","TRANSLATION_1_CELL_DURATION","translationAnimator","setUpdatedValueCallback","xVal","yVal","setState","addAnimator","isMergingInto","scaleAnimator","SCALING_DURATION","Component","BackgroundCell","MoveDirection","getRandomInt","max","floor","random","Cell","nextVal","mergedInto","mergingInto","cellIdentifier","nextIdentifierAvailable","amount","direction","GameBoard","rows","columns","cells","ROWS","COLUMNS","Array","fill","map","initializeGrid","cellsCopy","copy","nonEmptyCells","forEach","isEmpty","board","flatCells","flat","applyMoveAndClear","n","value","emptyCells","i","cIndex","emptyCell","splice","moveDirection","lines","line","slice","prevNonZeroCell","j","moveBy","markGettingMerged","markMerging","reduce","acc","cellsArray","Board","handleKeyDown","handleAnimationDone","gameBoard","spawnCells","acceptInput","expectedAnimations","boxes","newBoard","applyMoves","keyevent","moveDir","oldBoard","keyCode","move","document","addEventListener","removeEventListener","bgCells","generateBackgroundCells","valueCells","getNonEmptyCells","c","Header","Game","ReactDOM","render","getElementById"],"mappings":"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","file":"static/js/main.ab78c16c.chunk.js","sourcesContent":["class AnimationHelper {\r\n    constructor(duration) {\r\n        this.startTime = null;\r\n        this.duration = duration;\r\n        this.animationDone = false;\r\n    }\r\n\r\n    getTimeRatio(currentTime) {\r\n        if (this.startTime === null) {\r\n            this.startTime = currentTime;\r\n            return 0.0;\r\n        }\r\n\r\n        let elapsed = currentTime - this.startTime;\r\n        let ratio = Math.min(1.0, (elapsed / this.duration));\r\n\r\n        if (ratio >= 1)\r\n            this.animationDone = true;\r\n\r\n        return ratio;\r\n    }\r\n\r\n    isDone() {\r\n        return this.animationDone;\r\n    }\r\n\r\n    reset(startTime) {\r\n        this.startTime = startTime;\r\n        this.animationDone = false;\r\n    }\r\n}\r\n\r\nclass ValueAnimator {\r\n    constructor(fromValue, toValue, duration, reverse = false) {\r\n        this.fromValue = fromValue;\r\n        this.toValue = toValue;\r\n        this.valDiff = toValue - fromValue;\r\n        this.currentVal = fromValue;\r\n        this.reverse = reverse;\r\n        this.animationHelper = new AnimationHelper(duration);\r\n    }\r\n\r\n    setUpdatedValueCallback(callback) {\r\n        this.updateCallback = callback;\r\n        return this;\r\n    }\r\n\r\n    update(currentTime) {\r\n        let animationProgRatio = this.animationHelper.getTimeRatio(currentTime);\r\n        this.currentVal = this.fromValue + (this.valDiff * animationProgRatio);\r\n        if (this.updateCallback)\r\n            this.updateCallback(this.currentVal);\r\n        if (this.animationHelper.isDone() && this.reverse) {\r\n            this.reverse = false;\r\n            this.animationHelper.reset(currentTime);\r\n            let from = this.fromValue;\r\n            this.fromValue = this.toValue;\r\n            this.toValue = from;\r\n            this.valDiff = this.toValue - this.fromValue;\r\n            this.currentVal = this.fromValue;\r\n        }\r\n    }\r\n\r\n    getCurrentValue() {\r\n        return this.currentVal;\r\n    }\r\n\r\n    isCompleted() {\r\n        return this.animationHelper.isDone();\r\n    }\r\n}\r\n\r\nclass SequentialAnimator {\r\n\r\n    constructor() {\r\n        this.animationList = [];\r\n        this.currentAnimationIndex = 0;\r\n    }\r\n\r\n    update(currentTime) {\r\n        if (this.currentAnimationIndex < this.animationList.length) {\r\n            let currentAnim = this.animationList[this.currentAnimationIndex];\r\n            currentAnim.update(currentTime);\r\n            if (currentAnim.isCompleted())\r\n                this.currentAnimationIndex++;\r\n        }\r\n    }\r\n\r\n    addAnimator(animator) {\r\n        this.animationList.push(animator);\r\n    }\r\n\r\n    isCompleted() {\r\n        return this.animationList.every(anim => anim.isCompleted());\r\n    }\r\n\r\n}\r\n\r\nexport { ValueAnimator, SequentialAnimator};","import React from 'react';\r\nimport { SequentialAnimator, ValueAnimator } from '../helpers/animation';\r\n\r\nclass ValueCell extends React.Component {\r\n\r\n    static TRANSLATION_1_CELL_DURATION = 100;\r\n    static SCALING_DURATION = 100;\r\n\r\n    constructor(props) {\r\n        super(props);\r\n        this.divRef = React.createRef();\r\n        this.animate = this.animate.bind(this);\r\n        this.resetAnimationStatus();\r\n        this.state = { translationX: 0, translationY: 0, scaleFactor: 100 };\r\n        this.recycled = false;\r\n    }\r\n\r\n    render() {\r\n        let styles = {\r\n            gridRow: this.props.cell.row + 1,\r\n            gridColumn: this.props.cell.col + 1,\r\n        };\r\n\r\n        if (this.props.cell.isMoving()) {\r\n            styles['transform'] = `translate(${this.state.translationX}px, ${this.state.translationY}px) scale(${this.state.scaleFactor}%)`\r\n        }\r\n\r\n        let classesArray = [];\r\n        classesArray.push('value-cell');\r\n        classesArray.push(`value-${Math.min(2048, this.props.cell.val)}`);\r\n        classesArray.push(this.props.cell.isGettingMerged() ? 'value-cell-merged' : 'value-cell-top');\r\n        if(!this.recycled) {\r\n            classesArray.push('value-cell-pop-in')\r\n            this.recycled = true;\r\n        }\r\n\r\n        let classes = classesArray.join(' ');\r\n\r\n        return (\r\n            <div className={classes} style={styles} ref={this.divRef} >\r\n                {this.props.cell.val}\r\n            </div>\r\n        );\r\n    }\r\n\r\n    componentDidUpdate(prevProps) {\r\n        if (prevProps.cell.isMoving() && !this.props.cell.isMoving())\r\n            this.resetAnimationStatus();\r\n\r\n        if (this.props.cell.isMoving() && !this.animationDone && this.animationRequestId === 0) {\r\n            this.animation = this.prepareAnimation();\r\n            this.animationRequestId = window.requestAnimationFrame(this.animate);\r\n        }\r\n    }\r\n\r\n    componentWillUnmount() {\r\n        if (this.animationRequestId !== 0)\r\n            window.cancelAnimationFrame(this.animationRequestId);\r\n    }\r\n\r\n    animate(time) {\r\n        this.animation.update(time);\r\n\r\n        if (!this.animation.isCompleted())\r\n            this.animationRequestId = window.requestAnimationFrame(this.animate);\r\n        else {\r\n            this.animation = null;\r\n            this.animationDone = true;\r\n            this.animationRequestId = 0;\r\n            this.props.animationDoneCallback();\r\n        }\r\n    }\r\n\r\n    prepareAnimation() {\r\n        let totalAnimator = new SequentialAnimator();\r\n\r\n        // Translation\r\n        let xCellsDelta = this.props.cell.colDestination - this.props.cell.col;\r\n        let yCellsDelta = this.props.cell.rowDestination - this.props.cell.row;\r\n        let borderPx = Number.parseInt(getComputedStyle(this.divRef.current).getPropertyValue('--grid-border').trim().replace(\"px\", \"\"));\r\n        let boundingBox = this.divRef.current.getBoundingClientRect();\r\n        let cellWidth = boundingBox.width;\r\n        let cellHeight = boundingBox.height;\r\n        let xAxisMove = xCellsDelta !== 0;\r\n        let delta = xAxisMove ? (xCellsDelta * cellWidth) + (borderPx * xCellsDelta) : (yCellsDelta * cellHeight) + (borderPx * yCellsDelta);\r\n        let cellsDelta = xAxisMove ? xCellsDelta : yCellsDelta;\r\n        let translationDuration = Math.abs(cellsDelta) * ValueCell.TRANSLATION_1_CELL_DURATION;\r\n        let translationAnimator = new ValueAnimator(0, delta, translationDuration).setUpdatedValueCallback(val => {\r\n            let xVal = xCellsDelta !== 0 ? val : 0;\r\n            let yVal = yCellsDelta !== 0 ? val : 0;\r\n            this.setState({ translationX: xVal, translationY: yVal });\r\n        });\r\n        totalAnimator.addAnimator(translationAnimator);\r\n\r\n        // Merge animation, only if cell is merging\r\n        if (this.props.cell.isMergingInto()) {\r\n            let scaleAnimator = new ValueAnimator(100, 110, ValueCell.SCALING_DURATION, true).setUpdatedValueCallback(val => {\r\n                this.setState({ scaleFactor: val });\r\n            });\r\n            totalAnimator.addAnimator(scaleAnimator);\r\n        }\r\n\r\n        return totalAnimator;\r\n    }\r\n\r\n    resetAnimationStatus() {\r\n        this.animation = null;\r\n        this.animationDone = false;\r\n        this.animationRequestId = 0;\r\n    }\r\n}\r\n\r\nexport { ValueCell as default };","import React from 'react';\r\n\r\nclass BackgroundCell extends React.Component {\r\n    render() {\r\n        return (\r\n            <div className=\"bg-cell\" style={{ gridRow: this.props.row + 1, gridColumn: this.props.col + 1 }} />\r\n        );\r\n    }\r\n}\r\n\r\nexport { BackgroundCell as default };","const MoveDirection = {\r\n    UP: 0,\r\n    RIGHT: 1,\r\n    DOWN: 2,\r\n    LEFT: 3\r\n}\r\n\r\nfunction getRandomInt(max) {\r\n    return Math.floor(Math.random() * max);\r\n}\r\n\r\nclass Cell {\r\n\r\n    static nextIdentifierAvailable = 1;\r\n\r\n    constructor(row, col, val = 0, nextVal = 0, rowDestination = null, colDestination = null, mergedInto = false, mergingInto=false, cellIdentifier = null) {\r\n        this.row = row;\r\n        this.col = col;\r\n        this.val = val;\r\n        this.nextVal = nextVal;\r\n        this.rowDestination = rowDestination;\r\n        this.colDestination = colDestination;\r\n        this.mergedInto = mergedInto;\r\n        this.mergingInto = mergingInto;\r\n        this.cellIdentifier = cellIdentifier || Cell.nextIdentifierAvailable++;\r\n    }\r\n\r\n    isEmpty() {\r\n        return this.val === 0;\r\n    }\r\n\r\n    applyMoveAndClear() {\r\n        if (this.isMoving()) {\r\n            this.row = this.rowDestination;\r\n            this.col = this.colDestination;\r\n            if (this.nextVal !== 0) {\r\n                this.val = this.nextVal;\r\n                this.nextVal = 0;\r\n            }\r\n            this.rowDestination = null;\r\n            this.colDestination = null;\r\n            this.mergingInto = false;\r\n            this.mergedInto = false;\r\n        }\r\n    }\r\n\r\n    moveBy(amount, direction) {\r\n        if (this.rowDestination === null)\r\n            this.rowDestination = this.row;\r\n        if (this.colDestination === null)\r\n            this.colDestination = this.col;\r\n\r\n        switch (direction) {\r\n            case MoveDirection.UP: this.rowDestination = this.rowDestination - amount; break;\r\n            case MoveDirection.DOWN: this.rowDestination = this.rowDestination + amount; break;\r\n            case MoveDirection.LEFT: this.colDestination = this.colDestination - amount; break;\r\n            case MoveDirection.RIGHT: this.colDestination = this.colDestination + amount; break;\r\n            default: return;\r\n        }\r\n    }\r\n\r\n    isMoving() {\r\n        return this.rowDestination !== null || this.colDestination !== null;\r\n    }\r\n\r\n    markGettingMerged() {\r\n        this.mergedInto = true;\r\n    }\r\n\r\n    markMerging() {\r\n        this.mergingInto = true;\r\n    }\r\n\r\n    isGettingMerged() {\r\n        return this.mergedInto;\r\n    }\r\n\r\n    isMergingInto() {\r\n        return this.mergingInto;\r\n    }\r\n\r\n    copy() {\r\n        return new Cell(this.row, this.col, this.val, this.nextVal, this.rowDestination, this.colDestination, this.mergedInto, this.mergingInto, this.cellIdentifier);\r\n    }\r\n}\r\n\r\nclass GameBoard {\r\n    constructor(rows, columns, cells) {\r\n        this.ROWS = rows;\r\n        this.COLUMNS = columns;\r\n        if (cells)\r\n            this.cells = cells;\r\n        else {\r\n            this.cells = Array(rows).fill().map(() => Array(columns).fill());\r\n            GameBoard.initializeGrid(this.cells, rows, columns);\r\n        }\r\n    }\r\n\r\n    copy() {\r\n        let cellsCopy = this.cells.map((row) => row.map(cell => cell.copy()));\r\n        return new GameBoard(this.ROWS, this.COLUMNS, cellsCopy);\r\n    }\r\n\r\n    static initializeGrid(cellsArray, rows, columns) {\r\n        for (let i = 0; i < rows; i++)\r\n            for (let j = 0; j < columns; j++)\r\n                cellsArray[i][j] = new Cell(i, j);\r\n\r\n        return cellsArray;\r\n    }\r\n\r\n    getNonEmptyCells() {\r\n        let nonEmptyCells = [];\r\n\r\n        this.cells.forEach(row => {\r\n            row.forEach(cell => {\r\n                if (!cell.isEmpty())\r\n                    nonEmptyCells.push(cell);\r\n            });\r\n        });\r\n\r\n        return nonEmptyCells;\r\n    }\r\n\r\n    applyMoves() {\r\n        let board = this.copy();\r\n\r\n        let flatCells = board.cells.flat();\r\n\r\n        GameBoard.initializeGrid(board.cells, board.ROWS, board.COLUMNS);\r\n\r\n        flatCells.forEach(cell => {\r\n            if (cell.isMoving()) {\r\n                if (!cell.isGettingMerged()) {\r\n                    board.cells[cell.rowDestination][cell.colDestination] = cell;\r\n                    cell.applyMoveAndClear();\r\n                }\r\n            } else {\r\n                if (!cell.isEmpty() && !cell.isGettingMerged())\r\n                    board.cells[cell.row][cell.col] = cell;\r\n            }\r\n        });\r\n\r\n        return board;\r\n    }\r\n\r\n\r\n    spawnCells(n, value = 2) {\r\n        let emptyCells = [];\r\n\r\n        this.cells.forEach(row => {\r\n            row.forEach(cell => {\r\n                if (cell.isEmpty())\r\n                    emptyCells.push(cell);\r\n            });\r\n        });\r\n\r\n\r\n        if (emptyCells.length < n)\r\n            return false;\r\n\r\n        for (let i = 0; i < n; i++) {\r\n            let cIndex = getRandomInt(emptyCells.length);\r\n            let emptyCell = emptyCells[cIndex];\r\n            this.cells[emptyCell.row][emptyCell.col].val = value;\r\n            emptyCells.splice(cIndex, 1);\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    move(moveDirection) {\r\n        let board = this.copy();\r\n        let lines = [];\r\n\r\n        switch (moveDirection) {\r\n            case MoveDirection.UP:\r\n                for (let col = 0; col < board.COLUMNS; col++) {\r\n                    let line = [];\r\n                    for (let row = 0; row < board.ROWS; row++)\r\n                        line.push(board.cells[row][col]);\r\n                    lines.push(line);\r\n                }\r\n                break;\r\n            case MoveDirection.DOWN:\r\n                for (let col = 0; col < board.COLUMNS; col++) {\r\n                    let line = [];\r\n                    for (let row = board.ROWS - 1; row >= 0; row--)\r\n                        line.push(board.cells[row][col]);\r\n                    lines.push(line);\r\n                }\r\n                break;\r\n            case MoveDirection.LEFT:\r\n                lines = board.cells.map(row => row.slice());\r\n                break;\r\n            case MoveDirection.RIGHT:\r\n                lines = board.cells.map(row => row.slice().reverse());\r\n                break;\r\n            default: return;\r\n        }\r\n\r\n        lines.forEach(line => {\r\n            let prevNonZeroCell = null;\r\n            for (let i = 0; i < line.length; i++) {\r\n                let cell = line[i];\r\n                if (cell.isEmpty()) {\r\n                    for (let j = i + 1; j < line.length; j++)\r\n                        if (!line[j].isEmpty())\r\n                            line[j].moveBy(1, moveDirection);\r\n                } else {\r\n                    if (prevNonZeroCell === null) {\r\n                        prevNonZeroCell = cell;\r\n                    } else {\r\n                        if (prevNonZeroCell.val === cell.val) {\r\n                            prevNonZeroCell.markGettingMerged();\r\n                            cell.nextVal = cell.val * 2;\r\n                            cell.markMerging();\r\n\r\n                            for (let j = i; j < line.length; j++) {\r\n                                if (!line[j].isEmpty())\r\n                                    line[j].moveBy(1, moveDirection);\r\n                            }\r\n\r\n                            prevNonZeroCell = null;\r\n                        } else {\r\n                            prevNonZeroCell = cell;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        });\r\n\r\n        let diffs = board.cells.flat().reduce((acc, cell) => acc + (cell.isMoving() ? 1 : 0), 0);\r\n\r\n        if (!diffs)\r\n            return this;\r\n\r\n        return board;\r\n    }\r\n\r\n    toString() {\r\n        return this.cells.map(row => row.map(cell => cell.val).join(' ')).join('\\r\\n');\r\n    }\r\n}\r\n\r\nexport { MoveDirection, Cell, GameBoard }","import React from 'react';\r\nimport ValueCell from './valuecell'\r\nimport BackgroundCell from './backgroundcell';\r\nimport { MoveDirection, GameBoard } from '../logic/gamelogic';\r\n\r\nclass Board extends React.Component {\r\n    constructor(props) {\r\n        super(props);\r\n        this.handleKeyDown = this.handleKeyDown.bind(this);\r\n        this.handleAnimationDone = this.handleAnimationDone.bind(this);\r\n\r\n        let gameBoard = new GameBoard(props.rows, props.columns);\r\n        gameBoard.spawnCells(1);\r\n\r\n        this.state = { board: gameBoard };\r\n        this.acceptInput = true;\r\n        this.expectedAnimations = -1;\r\n    }\r\n\r\n    generateBackgroundCells(rows, columns) {\r\n        let boxes = [];\r\n\r\n        for (let i = 0; i < rows; i++)\r\n            for (let j = 0; j < columns; j++)\r\n                boxes.push(<BackgroundCell key={i * columns + j} row={i} col={j} />);\r\n\r\n        return boxes;\r\n    }\r\n\r\n    handleAnimationDone() {\r\n        this.expectedAnimations -= 1;\r\n\r\n        if (this.expectedAnimations === 0) {\r\n            let newBoard = this.state.board.applyMoves();\r\n            newBoard.spawnCells(1);\r\n            this.acceptInput = true;\r\n            this.setState({ board: newBoard });\r\n        }\r\n    }\r\n\r\n    handleKeyDown(keyevent) {\r\n        if (!this.acceptInput)\r\n            return;\r\n\r\n        let oldBoard = this.state.board;\r\n        let newBoard;\r\n        let moveDir;\r\n\r\n        switch (keyevent.keyCode) {\r\n            case 40: moveDir = MoveDirection.DOWN; break;\r\n            case 39: moveDir = MoveDirection.RIGHT; break;\r\n            case 38: moveDir = MoveDirection.UP; break;\r\n            case 37: moveDir = MoveDirection.LEFT; break;\r\n            default: return;\r\n        }\r\n\r\n        newBoard = oldBoard.move(moveDir);\r\n        if (newBoard !== oldBoard) {\r\n            this.acceptInput = false;\r\n            this.expectedAnimations = newBoard.cells.flat().reduce((acc, cell) => acc + (cell.isMoving() ? 1 : 0), 0);\r\n            this.setState({ board: newBoard });\r\n        }\r\n    }\r\n\r\n    componentDidMount() {\r\n        document.addEventListener(\"keydown\", this.handleKeyDown);\r\n    }\r\n\r\n    componentWillUnmount() {\r\n        document.removeEventListener(\"keydown\", this.handleKeyDown);\r\n    }\r\n\r\n    render() {\r\n        const bgCells = this.generateBackgroundCells(this.props.rows, this.props.columns);\r\n        const nonEmptyCells = this.state.board.getNonEmptyCells();\r\n        const valueCells = nonEmptyCells.map((c) => {\r\n            return <ValueCell key={c.cellIdentifier} cell={c} animationDoneCallback={this.handleAnimationDone} />\r\n        });\r\n\r\n        return (\r\n            <div className=\"gamegrid\">\r\n                {bgCells}\r\n                {valueCells}\r\n            </div>\r\n        );\r\n    }\r\n}\r\n\r\nexport { Board as default };\r\n","import React from 'react';\r\nimport Board from './board'\r\n\r\nclass Header extends React.Component {\r\n    render() {\r\n        return (\r\n            <div className=\"header\">\r\n                <h1> My-2048 </h1>\r\n            </div>\r\n        );\r\n    }\r\n}\r\n\r\nclass Game extends React.Component {\r\n    render() {\r\n        return (\r\n            <div className=\"gamecontainer\">\r\n                <Header />\r\n                <Board rows={this.props.rows} columns={this.props.columns} />\r\n            </div>\r\n        );\r\n    }\r\n}\r\n\r\nexport { Game as default };","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport Game from './components/game'\r\nimport './css/index.css';\r\n\r\nReactDOM.render(\r\n    <Game rows={4} columns={4} />,\r\n    document.getElementById('root')\r\n);"],"sourceRoot":""}