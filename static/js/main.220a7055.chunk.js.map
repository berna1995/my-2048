{"version":3,"sources":["logic.js","index.js"],"names":["MoveDirection","getRandomInt","max","Math","floor","random","Cell","row","col","val","nextVal","rowDestination","colDestination","mergedInto","cellIdentifier","this","nextIdentifierAvailable","isMoving","amount","direction","GameBoard","rows","columns","cells","ROWS","COLUMNS","Array","fill","map","initializeGrid","cellsCopy","cell","copy","nonEmptyCells","forEach","isEmpty","push","flatCells","flat","isGettingMerged","applyMoveAndClear","n","value","emptyCells","length","i","cIndex","emptyCell","splice","moveDirection","board","applyChanges","lines","line","slice","reverse","prevNonZeroCell","j","moveBy","markGettingMerged","reduce","acc","join","cellsArray","BackgroundCell","className","style","gridRow","props","gridColumn","React","Component","ValueCell","divRef","createRef","animate","bind","styles","cappedValue","min","classes","ref","time","prevProps","Board","handleKeyDown","gameBoard","spawnCells","state","boxes","keyevent","newBoard","moveDir","oldBoard","keyCode","move","setState","document","addEventListener","removeEventListener","bgCells","generateBackgroundCells","valueCells","getNonEmptyCells","c","Header","Game","ReactDOM","render","getElementById"],"mappings":"4MAAMA,G,MACE,GADFA,EAEK,EAFLA,EAGI,EAHJA,EAII,EAGV,SAASC,EAAaC,GAClB,OAAOC,KAAKC,MAAMD,KAAKE,SAAWH,G,IAGhCI,E,WAIF,WAAYC,EAAKC,GAAqH,IAAhHC,EAA+G,uDAAzG,EAAGC,EAAsG,uDAA5F,EAAGC,EAAyF,uDAAxE,KAAMC,EAAkE,uDAAjD,KAAMC,EAA2C,wDAAvBC,EAAuB,uDAAN,KAAM,oBACjIC,KAAKR,IAAMA,EACXQ,KAAKP,IAAMA,EACXO,KAAKN,IAAMA,EACXM,KAAKL,QAAUA,EACfK,KAAKJ,eAAiBA,EACtBI,KAAKH,eAAiBA,EACtBG,KAAKF,WAAaA,EAClBE,KAAKD,eAAiBA,GAAkBR,EAAKU,0B,2CAGjD,WACI,OAAoB,IAAbD,KAAKN,M,+BAGhB,WACQM,KAAKE,aACLF,KAAKR,IAAMQ,KAAKJ,eAChBI,KAAKP,IAAMO,KAAKH,eACK,IAAjBG,KAAKL,UACLK,KAAKN,IAAMM,KAAKL,QAChBK,KAAKL,QAAU,GAEnBK,KAAKJ,eAAiB,KACtBI,KAAKH,eAAiB,Q,oBAI9B,SAAOM,EAAQC,GAMX,OAL4B,OAAxBJ,KAAKJ,iBACLI,KAAKJ,eAAiBI,KAAKR,KACH,OAAxBQ,KAAKH,iBACLG,KAAKH,eAAiBG,KAAKP,KAEvBW,GACJ,KAAKnB,EAAkBe,KAAKJ,eAAiBI,KAAKJ,eAAiBO,EAAQ,MAC3E,KAAKlB,EAAoBe,KAAKJ,eAAiBI,KAAKJ,eAAiBO,EAAQ,MAC7E,KAAKlB,EAAoBe,KAAKH,eAAiBG,KAAKH,eAAiBM,EAAQ,MAC7E,KAAKlB,EAAqBe,KAAKH,eAAiBG,KAAKH,eAAiBM,EAAQ,MAC9E,QAAS,U,sBAIjB,WACI,OAA+B,OAAxBH,KAAKJ,gBAAmD,OAAxBI,KAAKH,iB,+BAGhD,WACIG,KAAKF,YAAa,I,6BAGtB,WACI,OAAOE,KAAKF,a,kBAGhB,WACI,OAAO,IAAIP,EAAKS,KAAKR,IAAKQ,KAAKP,IAAKO,KAAKN,IAAKM,KAAKL,QAASK,KAAKJ,eAAgBI,KAAKH,eAAgBG,KAAKF,WAAYE,KAAKD,oB,KA5D9HR,EAEKU,wBAA0B,E,IA8D/BI,E,WACF,WAAYC,EAAMC,EAASC,GAAQ,oBAC/BR,KAAKS,KAAOH,EACZN,KAAKU,QAAUH,EACXC,EACAR,KAAKQ,MAAQA,GAEbR,KAAKQ,MAAQG,MAAML,GAAMM,OAAOC,KAAI,kBAAMF,MAAMJ,GAASK,UACzDP,EAAUS,eAAed,KAAKQ,MAAOF,EAAMC,I,wCAInD,WACI,IAAIQ,EAAYf,KAAKQ,MAAMK,KAAI,SAACrB,GAAD,OAASA,EAAIqB,KAAI,SAAAG,GAAI,OAAIA,EAAKC,aAC7D,OAAO,IAAIZ,EAAUL,KAAKS,KAAMT,KAAKU,QAASK,K,8BAWlD,WACI,IAAIG,EAAgB,GASpB,OAPAlB,KAAKQ,MAAMW,SAAQ,SAAA3B,GACfA,EAAI2B,SAAQ,SAAAH,GACHA,EAAKI,WACNF,EAAcG,KAAKL,SAIxBE,I,0BAGX,WAAgB,IAAD,OACPI,EAAYtB,KAAKQ,MAAMe,OAgB3B,OAdAlB,EAAUS,eAAed,KAAKQ,MAAOR,KAAKS,KAAMT,KAAKU,SAErDY,EAAUH,SAAQ,SAAAH,GACVA,EAAKd,WACAc,EAAKQ,oBACN,EAAKhB,MAAMQ,EAAKpB,gBAAgBoB,EAAKnB,gBAAkBmB,EACvDA,EAAKS,qBAGJT,EAAKI,WAAcJ,EAAKQ,oBACzB,EAAKhB,MAAMQ,EAAKxB,KAAKwB,EAAKvB,KAAOuB,MAItChB,O,wBAIX,SAAW0B,GAAe,IAAZC,EAAW,uDAAH,EACdC,EAAa,GAUjB,GARA5B,KAAKQ,MAAMW,SAAQ,SAAA3B,GACfA,EAAI2B,SAAQ,SAAAH,GACJA,EAAKI,WACLQ,EAAWP,KAAKL,SAKxBY,EAAWC,OAASH,EACpB,OAAO,EAEX,IAAK,IAAII,EAAI,EAAGA,EAAIJ,EAAGI,IAAK,CACxB,IAAIC,EAAS7C,EAAa0C,EAAWC,QACjCG,EAAYJ,EAAWG,GAC3B/B,KAAKQ,MAAMwB,EAAUxC,KAAKwC,EAAUvC,KAAKC,IAAMiC,EAC/CC,EAAWK,OAAOF,EAAQ,GAG9B,OAAO,I,kBAGX,SAAKG,GACD,IAAIC,EAAQnC,KAAKiB,OAAOmB,eACpBC,EAAQ,GAEZ,OAAQH,GACJ,KAAKjD,EACD,IAAK,IAAIQ,EAAM,EAAGA,EAAM0C,EAAMzB,QAASjB,IAAO,CAE1C,IADA,IAAI6C,EAAO,GACF9C,EAAM,EAAGA,EAAM2C,EAAM1B,KAAMjB,IAChC8C,EAAKjB,KAAKc,EAAM3B,MAAMhB,GAAKC,IAC/B4C,EAAMhB,KAAKiB,GAEf,MACJ,KAAKrD,EACD,IAAK,IAAIQ,EAAM,EAAGA,EAAM0C,EAAMzB,QAASjB,IAAO,CAE1C,IADA,IAAI6C,EAAO,GACF9C,EAAM2C,EAAM1B,KAAO,EAAGjB,GAAO,EAAGA,IACrC8C,EAAKjB,KAAKc,EAAM3B,MAAMhB,GAAKC,IAC/B4C,EAAMhB,KAAKiB,GAEf,MACJ,KAAKrD,EACDoD,EAAQF,EAAM3B,MAAMK,KAAI,SAAArB,GAAG,OAAIA,EAAI+C,WACnC,MACJ,KAAKtD,EACDoD,EAAQF,EAAM3B,MAAMK,KAAI,SAAArB,GAAG,OAAIA,EAAI+C,QAAQC,aAC3C,MACJ,QAAS,OAmCb,OAhCAH,EAAMlB,SAAQ,SAAAmB,GAEV,IADA,IAAIG,EAAkB,KACbX,EAAI,EAAGA,EAAIQ,EAAKT,OAAQC,IAAK,CAClC,IAAId,EAAOsB,EAAKR,GAChB,GAAId,EAAKI,UACL,IAAK,IAAIsB,EAAIZ,EAAI,EAAGY,EAAIJ,EAAKT,OAAQa,IAC5BJ,EAAKI,GAAGtB,WACTkB,EAAKI,GAAGC,OAAO,EAAGT,QAE1B,GAAwB,OAApBO,EACAA,EAAkBzB,OAElB,GAAIyB,EAAgB/C,MAAQsB,EAAKtB,IAAK,CAClC+C,EAAgBG,oBAChB5B,EAAKrB,QAAqB,EAAXqB,EAAKtB,IAEpB,IAAK,IAAIgD,EAAIZ,EAAGY,EAAIJ,EAAKT,OAAQa,IACxBJ,EAAKI,GAAGtB,WACTkB,EAAKI,GAAGC,OAAO,EAAGT,GAG1BO,EAAkB,UAElBA,EAAkBzB,MAO1BmB,EAAM3B,MAAMe,OAAOsB,QAAO,SAACC,EAAK9B,GAAN,OAAe8B,GAAO9B,EAAKd,WAAa,EAAI,KAAI,GAK/EiC,EAFInC,O,sBAKf,WACI,OAAOA,KAAKQ,MAAMK,KAAI,SAAArB,GAAG,OAAIA,EAAIqB,KAAI,SAAAG,GAAI,OAAIA,EAAKtB,OAAKqD,KAAK,QAAMA,KAAK,W,6BAvI3E,SAAsBC,EAAY1C,EAAMC,GACpC,IAAK,IAAIuB,EAAI,EAAGA,EAAIxB,EAAMwB,IACtB,IAAK,IAAIY,EAAI,EAAGA,EAAInC,EAASmC,IACzBM,EAAWlB,GAAGY,GAAK,IAAInD,EAAKuC,EAAGY,GAEvC,OAAOM,M,YC5FTC,E,4JACF,WACI,OACI,qBAAKC,UAAU,UAAUC,MAAO,CAAEC,QAASpD,KAAKqD,MAAM7D,IAAM,EAAG8D,WAAYtD,KAAKqD,MAAM5D,IAAM,S,GAH3E8D,IAAMC,WAQ7BC,E,kDACF,WAAYJ,GAAQ,IAAD,8BACf,cAAMA,IACDK,OAASH,IAAMI,YACpB,EAAKC,QAAU,EAAKA,QAAQC,KAAb,gBAHA,E,0CAMnB,WACI,IAAIC,EAAS,CACTV,QAASpD,KAAKqD,MAAMrC,KAAKxB,IAAM,EAC/B8D,WAAYtD,KAAKqD,MAAMrC,KAAKvB,IAAM,GAGlCsE,EAAc3E,KAAK4E,IAAI,KAAMhE,KAAKqD,MAAMrC,KAAKtB,KAC7CuE,EAAO,2BAAuBF,GAElC,OACI,qBAAKb,UAAWe,EAASd,MAAOW,EAAQI,IAAKlE,KAAK0D,OAAlD,SACK1D,KAAKqD,MAAMrC,KAAKtB,Q,qBAK7B,SAAQyE,M,gCAGR,SAAmBC,Q,GA1BCb,IAAMC,WA8BxBa,E,kDACF,WAAYhB,GAAQ,IAAD,uBACf,cAAMA,IACDiB,cAAgB,EAAKA,cAAcT,KAAnB,gBACrB,IAAIU,EAAY,IAAIlE,EAAUgD,EAAM/C,KAAM+C,EAAM9C,SAHjC,OAIfgE,EAAUC,WAAW,GACrB,EAAKC,MAAQ,CAAEtC,MAAOoC,GALP,E,2DAQnB,SAAwBjE,EAAMC,GAG1B,IAFA,IAAImE,EAAQ,GAEH5C,EAAI,EAAGA,EAAIxB,EAAMwB,IACtB,IAAK,IAAIY,EAAI,EAAGA,EAAInC,EAASmC,IACzBgC,EAAMrD,KAAK,cAAC,EAAD,CAAsC7B,IAAKsC,EAAGrC,IAAKiD,GAA9BZ,EAAIvB,EAAUmC,IAEtD,OAAOgC,I,2BAGX,SAAcC,GAeV,IACIC,EACAC,EAFAC,EAAW9E,KAAKyE,MAAMtC,MAI1B,OAAQwC,EAASI,SACb,KAAK,GAAIF,EAAU5F,EAAoB,MACvC,KAAK,GAAI4F,EAAU5F,EAAqB,MACxC,KAAK,GAAI4F,EAAU5F,EAAkB,MACrC,KAAK,GAAI4F,EAAU5F,EAAoB,MACvC,QAAS,QAGb2F,EAAWE,EAASE,KAAKH,MACRC,IACbF,EAASxC,eACTwC,EAASJ,WAAW,GACpBxE,KAAKiF,SAAS,CAAE9C,MAAOyC,O,+BAI/B,WACIM,SAASC,iBAAiB,UAAWnF,KAAKsE,iB,kCAG9C,WACIY,SAASE,oBAAoB,UAAWpF,KAAKsE,iB,oBAGjD,WACI,IAAMe,EAAUrF,KAAKsF,wBAAwBtF,KAAKqD,MAAM/C,KAAMN,KAAKqD,MAAM9C,SACnEgF,EAAavF,KAAKyE,MAAMtC,MAAMqD,mBAAmB3E,KAAI,SAAC4E,GACxD,OAAO,cAAC,EAAD,CAAkCzE,KAAMyE,GAAxBA,EAAE1F,mBAG7B,OACI,sBAAKmD,UAAU,WAAf,UACKmC,EACAE,S,GAvEGhC,IAAMC,WA6EpBkC,E,4JACF,WACI,OACI,qBAAKxC,UAAU,SAAf,SACI,iD,GAJKK,IAAMC,WAUrBmC,E,4JACF,WACI,OACI,sBAAKzC,UAAU,gBAAf,UACI,cAAC,EAAD,IACA,cAAC,EAAD,CAAO5C,KAAMN,KAAKqD,MAAM/C,KAAMC,QAASP,KAAKqD,MAAM9C,iB,GAL/CgD,IAAMC,WAazBoC,IAASC,OACL,cAAC,EAAD,CAAMvF,KAAM,EAAGC,QAAS,IACxB2E,SAASY,eAAe,W","file":"static/js/main.220a7055.chunk.js","sourcesContent":["const MoveDirection = {\r\n    UP: 0,\r\n    RIGHT: 1,\r\n    DOWN: 2,\r\n    LEFT: 3\r\n}\r\n\r\nfunction getRandomInt(max) {\r\n    return Math.floor(Math.random() * max);\r\n}\r\n\r\nclass Cell {\r\n\r\n    static nextIdentifierAvailable = 1;\r\n\r\n    constructor(row, col, val = 0, nextVal = 0, rowDestination = null, colDestination = null, mergedInto = false, cellIdentifier = null) {\r\n        this.row = row;\r\n        this.col = col;\r\n        this.val = val;\r\n        this.nextVal = nextVal;\r\n        this.rowDestination = rowDestination;\r\n        this.colDestination = colDestination;\r\n        this.mergedInto = mergedInto;\r\n        this.cellIdentifier = cellIdentifier || Cell.nextIdentifierAvailable++;\r\n    }\r\n\r\n    isEmpty() {\r\n        return this.val === 0;\r\n    }\r\n\r\n    applyMoveAndClear() {\r\n        if (this.isMoving()) {\r\n            this.row = this.rowDestination;\r\n            this.col = this.colDestination;\r\n            if (this.nextVal !== 0) {\r\n                this.val = this.nextVal;\r\n                this.nextVal = 0;\r\n            }\r\n            this.rowDestination = null;\r\n            this.colDestination = null;\r\n        }\r\n    }\r\n\r\n    moveBy(amount, direction) {\r\n        if (this.rowDestination === null)\r\n            this.rowDestination = this.row;\r\n        if (this.colDestination === null)\r\n            this.colDestination = this.col;\r\n\r\n        switch (direction) {\r\n            case MoveDirection.UP: this.rowDestination = this.rowDestination - amount; break;\r\n            case MoveDirection.DOWN: this.rowDestination = this.rowDestination + amount; break;\r\n            case MoveDirection.LEFT: this.colDestination = this.colDestination - amount; break;\r\n            case MoveDirection.RIGHT: this.colDestination = this.colDestination + amount; break;\r\n            default: return;\r\n        }\r\n    }\r\n\r\n    isMoving() {\r\n        return this.rowDestination !== null || this.colDestination !== null;\r\n    }\r\n\r\n    markGettingMerged() {\r\n        this.mergedInto = true;\r\n    }\r\n\r\n    isGettingMerged() {\r\n        return this.mergedInto;\r\n    }\r\n\r\n    copy() {\r\n        return new Cell(this.row, this.col, this.val, this.nextVal, this.rowDestination, this.colDestination, this.mergedInto, this.cellIdentifier);\r\n    }\r\n}\r\n\r\nclass GameBoard {\r\n    constructor(rows, columns, cells) {\r\n        this.ROWS = rows;\r\n        this.COLUMNS = columns;\r\n        if (cells)\r\n            this.cells = cells;\r\n        else {\r\n            this.cells = Array(rows).fill().map(() => Array(columns).fill());\r\n            GameBoard.initializeGrid(this.cells, rows, columns);\r\n        }\r\n    }\r\n\r\n    copy() {\r\n        let cellsCopy = this.cells.map((row) => row.map(cell => cell.copy()));\r\n        return new GameBoard(this.ROWS, this.COLUMNS, cellsCopy);\r\n    }\r\n\r\n    static initializeGrid(cellsArray, rows, columns) {\r\n        for (let i = 0; i < rows; i++)\r\n            for (let j = 0; j < columns; j++)\r\n                cellsArray[i][j] = new Cell(i, j);\r\n\r\n        return cellsArray;\r\n    }\r\n\r\n    getNonEmptyCells() {\r\n        let nonEmptyCells = [];\r\n\r\n        this.cells.forEach(row => {\r\n            row.forEach(cell => {\r\n                if (!cell.isEmpty())\r\n                    nonEmptyCells.push(cell);\r\n            });\r\n        });\r\n\r\n        return nonEmptyCells;\r\n    }\r\n\r\n    applyChanges() {\r\n        let flatCells = this.cells.flat();\r\n\r\n        GameBoard.initializeGrid(this.cells, this.ROWS, this.COLUMNS);\r\n\r\n        flatCells.forEach(cell => {\r\n            if (cell.isMoving()) {\r\n                if (!cell.isGettingMerged()) {\r\n                    this.cells[cell.rowDestination][cell.colDestination] = cell;\r\n                    cell.applyMoveAndClear();\r\n                }\r\n            } else {\r\n                if (!cell.isEmpty() && !cell.isGettingMerged())\r\n                    this.cells[cell.row][cell.col] = cell;\r\n            }\r\n        });\r\n\r\n        return this;\r\n    }\r\n\r\n\r\n    spawnCells(n, value = 2) {\r\n        let emptyCells = [];\r\n\r\n        this.cells.forEach(row => {\r\n            row.forEach(cell => {\r\n                if (cell.isEmpty())\r\n                    emptyCells.push(cell);\r\n            });\r\n        });\r\n\r\n\r\n        if (emptyCells.length < n)\r\n            return false;\r\n\r\n        for (let i = 0; i < n; i++) {\r\n            let cIndex = getRandomInt(emptyCells.length);\r\n            let emptyCell = emptyCells[cIndex];\r\n            this.cells[emptyCell.row][emptyCell.col].val = value;\r\n            emptyCells.splice(cIndex, 1);\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    move(moveDirection) {\r\n        let board = this.copy().applyChanges();\r\n        let lines = [];\r\n\r\n        switch (moveDirection) {\r\n            case MoveDirection.UP:\r\n                for (let col = 0; col < board.COLUMNS; col++) {\r\n                    let line = [];\r\n                    for (let row = 0; row < board.ROWS; row++)\r\n                        line.push(board.cells[row][col]);\r\n                    lines.push(line);\r\n                }\r\n                break;\r\n            case MoveDirection.DOWN:\r\n                for (let col = 0; col < board.COLUMNS; col++) {\r\n                    let line = [];\r\n                    for (let row = board.ROWS - 1; row >= 0; row--)\r\n                        line.push(board.cells[row][col]);\r\n                    lines.push(line);\r\n                }\r\n                break;\r\n            case MoveDirection.LEFT:\r\n                lines = board.cells.map(row => row.slice());\r\n                break;\r\n            case MoveDirection.RIGHT:\r\n                lines = board.cells.map(row => row.slice().reverse());\r\n                break;\r\n            default: return;\r\n        }\r\n\r\n        lines.forEach(line => {\r\n            let prevNonZeroCell = null;\r\n            for (let i = 0; i < line.length; i++) {\r\n                let cell = line[i];\r\n                if (cell.isEmpty()) {\r\n                    for (let j = i + 1; j < line.length; j++)\r\n                        if (!line[j].isEmpty())\r\n                            line[j].moveBy(1, moveDirection);\r\n                } else {\r\n                    if (prevNonZeroCell === null) {\r\n                        prevNonZeroCell = cell;\r\n                    } else {\r\n                        if (prevNonZeroCell.val === cell.val) {\r\n                            prevNonZeroCell.markGettingMerged();\r\n                            cell.nextVal = cell.val * 2;\r\n\r\n                            for (let j = i; j < line.length; j++) {\r\n                                if (!line[j].isEmpty())\r\n                                    line[j].moveBy(1, moveDirection);\r\n                            }\r\n\r\n                            prevNonZeroCell = null;\r\n                        } else {\r\n                            prevNonZeroCell = cell;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        });\r\n\r\n        let diffs = board.cells.flat().reduce((acc, cell) => acc + (cell.isMoving() ? 1 : 0), 0);\r\n\r\n        if (!diffs)\r\n            return this;\r\n\r\n        return board;\r\n    }\r\n\r\n    toString() {\r\n        return this.cells.map(row => row.map(cell => cell.val).join(' ')).join('\\r\\n');\r\n    }\r\n}\r\n\r\nexport { MoveDirection, Cell, GameBoard }","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport './index.css';\r\nimport { GameBoard, MoveDirection, Cell } from './logic';\r\n\r\nclass BackgroundCell extends React.Component {\r\n    render() {\r\n        return (\r\n            <div className=\"bg-cell\" style={{ gridRow: this.props.row + 1, gridColumn: this.props.col + 1 }} />\r\n        );\r\n    }\r\n}\r\n\r\nclass ValueCell extends React.Component {\r\n    constructor(props) {\r\n        super(props);\r\n        this.divRef = React.createRef();\r\n        this.animate = this.animate.bind(this);\r\n    }\r\n\r\n    render() {\r\n        let styles = {\r\n            gridRow: this.props.cell.row + 1,\r\n            gridColumn: this.props.cell.col + 1,\r\n        };\r\n\r\n        let cappedValue = Math.min(2048, this.props.cell.val);\r\n        let classes = `value-cell value-${cappedValue}`; \r\n\r\n        return (\r\n            <div className={classes} style={styles} ref={this.divRef} >\r\n                {this.props.cell.val}\r\n            </div>\r\n        );\r\n    }\r\n\r\n    animate(time) {\r\n    }\r\n\r\n    componentDidUpdate(prevProps) {\r\n    }\r\n}\r\n\r\nclass Board extends React.Component {\r\n    constructor(props) {\r\n        super(props);\r\n        this.handleKeyDown = this.handleKeyDown.bind(this);\r\n        let gameBoard = new GameBoard(props.rows, props.columns);\r\n        gameBoard.spawnCells(1);\r\n        this.state = { board: gameBoard };\r\n    }\r\n\r\n    generateBackgroundCells(rows, columns) {\r\n        let boxes = [];\r\n\r\n        for (let i = 0; i < rows; i++)\r\n            for (let j = 0; j < columns; j++)\r\n                boxes.push(<BackgroundCell key={i * columns + j} row={i} col={j} />);\r\n\r\n        return boxes;\r\n    }\r\n\r\n    handleKeyDown(keyevent) {\r\n\r\n        /**\r\n         * The idea here.\r\n         * 1. Create new board starting from previous one\r\n         * 2. Check for diffs (move returns this if no diff)\r\n         * 3. Render the new cells animating\r\n         * 4. When animations are done\r\n         *  4.1 Apply changes to the board\r\n         *  4.2 Spawn new cell(s) if possible\r\n         *  4.3 Render again new cell(s) animation\r\n         * 5. Check if won/lost maybe?\r\n         * 6. Accept user input again (should be blocked from pt 3 to pt 5)\r\n         */\r\n\r\n        let oldBoard = this.state.board;\r\n        let newBoard;\r\n        let moveDir;\r\n\r\n        switch (keyevent.keyCode) {\r\n            case 40: moveDir = MoveDirection.DOWN; break;\r\n            case 39: moveDir = MoveDirection.RIGHT; break;\r\n            case 38: moveDir = MoveDirection.UP; break;\r\n            case 37: moveDir = MoveDirection.LEFT; break;\r\n            default: return;\r\n        }\r\n\r\n        newBoard = oldBoard.move(moveDir);\r\n        if (newBoard !== oldBoard) {\r\n            newBoard.applyChanges();\r\n            newBoard.spawnCells(1);\r\n            this.setState({ board: newBoard });\r\n        }\r\n    }\r\n\r\n    componentDidMount() {\r\n        document.addEventListener(\"keydown\", this.handleKeyDown);\r\n    }\r\n\r\n    componentWillUnmount() {\r\n        document.removeEventListener(\"keydown\", this.handleKeyDown);\r\n    }\r\n\r\n    render() {\r\n        const bgCells = this.generateBackgroundCells(this.props.rows, this.props.columns);\r\n        const valueCells = this.state.board.getNonEmptyCells().map((c) => {\r\n            return <ValueCell key={c.cellIdentifier} cell={c} />\r\n        });\r\n\r\n        return (\r\n            <div className=\"gamegrid\">\r\n                {bgCells}\r\n                {valueCells}\r\n            </div>\r\n        );\r\n    }\r\n}\r\n\r\nclass Header extends React.Component {\r\n    render() {\r\n        return (\r\n            <div className=\"header\">\r\n                <h1> My-2048 </h1>\r\n            </div>\r\n        );\r\n    }\r\n}\r\n\r\nclass Game extends React.Component {\r\n    render() {\r\n        return (\r\n            <div className=\"gamecontainer\">\r\n                <Header />\r\n                <Board rows={this.props.rows} columns={this.props.columns} />\r\n            </div>\r\n        );\r\n    }\r\n}\r\n\r\n// ========================================\r\n\r\nReactDOM.render(\r\n    <Game rows={4} columns={4} />,\r\n    document.getElementById('root')\r\n);"],"sourceRoot":""}