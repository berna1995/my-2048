{"version":3,"sources":["helpers/animation.js","components/valuecell.js","components/backgroundcell.js","utils/utils.js","logic/gamelogic.js","components/board.js","storage/storage.js","components/game.js","index.js"],"names":["AnimationHelper","duration","this","startTime","animationDone","currentTime","elapsed","ratio","Math","min","ValueAnimator","fromValue","toValue","reverse","valDiff","currentVal","animationHelper","callback","updateCallback","animationProgRatio","getTimeRatio","isDone","reset","from","SequentialAnimator","animationList","currentAnimationIndex","length","currentAnim","update","isCompleted","animator","push","every","anim","ValueCell","props","divRef","React","createRef","animate","bind","resetAnimationStatus","state","translationX","translationY","scaleFactor","recycled","styles","gridRow","cell","row","gridColumn","col","isMoving","classesArray","val","isGettingMerged","classes","join","className","style","ref","prevProps","animationRequestId","animation","prepareAnimation","window","requestAnimationFrame","cancelAnimationFrame","time","animationDoneCallback","totalAnimator","xCellsDelta","colDestination","yCellsDelta","rowDestination","borderPx","Number","parseInt","getComputedStyle","current","getPropertyValue","trim","replace","boundingBox","getBoundingClientRect","cellWidth","width","cellHeight","height","xAxisMove","delta","cellsDelta","translationDuration","abs","TRANSLATION_1_CELL_DURATION","translationAnimator","setUpdatedValueCallback","xVal","yVal","setState","addAnimator","isMergingInto","scaleAnimator","SCALING_DURATION","Component","BackgroundCell","getRandomInt","max","floor","random","MoveDirection","GameStatus","Cell","nextVal","mergedInto","mergingInto","cellIdentifier","nextIdentifierAvailable","amount","direction","GameBoard","rows","columns","cells","ROWS","COLUMNS","Array","fill","map","initializeGrid","cellsCopy","copy","nonEmptyCells","forEach","isEmpty","inPlace","board","flatCells","flat","applyMoveAndClear","n","value","emptyCells","i","cIndex","emptyCell","splice","moveDirection","lines","line","slice","prevNonZeroCell","j","moveBy","markGettingMerged","markMerging","diffs","reduce","acc","winConditionThreshold","hasWon","some","possibleMoves","hasMoveAvailable","move","cellsArray","Board","handleKeyDown","handleAnimationDone","isConstructor","gameBoard","spawnCells","acceptInput","expectedAnimations","autoMode","autoModeToken","autoModeIndex","gameStatus","boxes","newBoard","applyMoves","currentStatus","checkGameStatus","onMoveDone","getMoveScore","autoPlay","keyevent","moveDir","oldBoard","key","keyCode","setTimeout","nextBoard","currentBoard","m","nxt","document","addEventListener","registerResetCallback","removeEventListener","bgCells","generateBackgroundCells","valueCells","getNonEmptyCells","c","gridOverlay","Storage","undefined","localStorage","fallbackStorage","supportsLocalStorage","gridSize","toString","score","getItem","setItem","Header","title","bgcolor","currentScore","topScore","options","onGridSizeChanged","defaultGridSize","onNewGameClicked","GridSizeSelector","onChange","myRef","event","data","blur","Ref","innerRef","Dropdown","margin","text","icon","labeled","floating","button","defaultValue","closeOnBlur","NewGameButton","onClick","target","Button","color","ScoreDisplay","backgroundColor","Game","DEFAULT_ROWS","DEFAULT_COLS","gridOptions","handleGridResize","handleNewGameClicked","setNewGameHandler","handleMoveDone","storage","newSize","handler","newGameHandler","moveScore","console","log","newScore","getHighestScore","setHighestScore","href","ReactDOM","render","getElementById"],"mappings":"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","file":"static/js/main.ad318220.chunk.js","sourcesContent":["class AnimationHelper {\r\n    constructor(duration) {\r\n        this.startTime = null;\r\n        this.duration = duration;\r\n        this.animationDone = false;\r\n    }\r\n\r\n    getTimeRatio(currentTime) {\r\n        if (this.startTime === null) {\r\n            this.startTime = currentTime;\r\n            return 0.0;\r\n        }\r\n\r\n        let elapsed = currentTime - this.startTime;\r\n        let ratio = Math.min(1.0, (elapsed / this.duration));\r\n\r\n        if (ratio >= 1)\r\n            this.animationDone = true;\r\n\r\n        return ratio;\r\n    }\r\n\r\n    isDone() {\r\n        return this.animationDone;\r\n    }\r\n\r\n    reset(startTime) {\r\n        this.startTime = startTime;\r\n        this.animationDone = false;\r\n    }\r\n}\r\n\r\nclass ValueAnimator {\r\n    constructor(fromValue, toValue, duration, reverse = false) {\r\n        this.fromValue = fromValue;\r\n        this.toValue = toValue;\r\n        this.valDiff = toValue - fromValue;\r\n        this.currentVal = fromValue;\r\n        this.reverse = reverse;\r\n        this.animationHelper = new AnimationHelper(duration);\r\n    }\r\n\r\n    setUpdatedValueCallback(callback) {\r\n        this.updateCallback = callback;\r\n        return this;\r\n    }\r\n\r\n    update(currentTime) {\r\n        let animationProgRatio = this.animationHelper.getTimeRatio(currentTime);\r\n        this.currentVal = this.fromValue + (this.valDiff * animationProgRatio);\r\n        if (this.updateCallback)\r\n            this.updateCallback(this.currentVal);\r\n        if (this.animationHelper.isDone() && this.reverse) {\r\n            this.reverse = false;\r\n            this.animationHelper.reset(currentTime);\r\n            let from = this.fromValue;\r\n            this.fromValue = this.toValue;\r\n            this.toValue = from;\r\n            this.valDiff = this.toValue - this.fromValue;\r\n            this.currentVal = this.fromValue;\r\n        }\r\n    }\r\n\r\n    getCurrentValue() {\r\n        return this.currentVal;\r\n    }\r\n\r\n    isCompleted() {\r\n        return this.animationHelper.isDone();\r\n    }\r\n}\r\n\r\nclass SequentialAnimator {\r\n\r\n    constructor() {\r\n        this.animationList = [];\r\n        this.currentAnimationIndex = 0;\r\n    }\r\n\r\n    update(currentTime) {\r\n        if (this.currentAnimationIndex < this.animationList.length) {\r\n            let currentAnim = this.animationList[this.currentAnimationIndex];\r\n            currentAnim.update(currentTime);\r\n            if (currentAnim.isCompleted())\r\n                this.currentAnimationIndex++;\r\n        }\r\n    }\r\n\r\n    addAnimator(animator) {\r\n        this.animationList.push(animator);\r\n    }\r\n\r\n    isCompleted() {\r\n        return this.animationList.every(anim => anim.isCompleted());\r\n    }\r\n\r\n}\r\n\r\nexport { ValueAnimator, SequentialAnimator};","import React from 'react';\r\nimport { SequentialAnimator, ValueAnimator } from '../helpers/animation';\r\n\r\nclass ValueCell extends React.Component {\r\n\r\n    static TRANSLATION_1_CELL_DURATION = 50;\r\n    static SCALING_DURATION = 100;\r\n\r\n    constructor(props) {\r\n        super(props);\r\n        this.divRef = React.createRef();\r\n        this.animate = this.animate.bind(this);\r\n        this.resetAnimationStatus();\r\n        this.state = { translationX: 0, translationY: 0, scaleFactor: 100 };\r\n        this.recycled = false;\r\n    }\r\n\r\n    render() {\r\n        let styles = {\r\n            gridRow: this.props.cell.row + 1,\r\n            gridColumn: this.props.cell.col + 1,\r\n        };\r\n\r\n        if (this.props.cell.isMoving()) {\r\n            styles['transform'] = `translate(${this.state.translationX}px, ${this.state.translationY}px) scale(${this.state.scaleFactor}%)`\r\n        }\r\n\r\n        let classesArray = [];\r\n        classesArray.push('value-cell');\r\n        classesArray.push(`value-${Math.min(2048, this.props.cell.val)}`);\r\n        classesArray.push(this.props.cell.isGettingMerged() ? 'value-cell-merged' : 'value-cell-top');\r\n        if(!this.recycled) {\r\n            classesArray.push('value-cell-pop-in')\r\n            this.recycled = true;\r\n        }\r\n\r\n        let classes = classesArray.join(' ');\r\n\r\n        return (\r\n            <div className={classes} style={styles} ref={this.divRef} >\r\n                {this.props.cell.val}\r\n            </div>\r\n        );\r\n    }\r\n\r\n    componentDidUpdate(prevProps) {\r\n        if (prevProps.cell.isMoving() && !this.props.cell.isMoving())\r\n            this.resetAnimationStatus();\r\n\r\n        if (this.props.cell.isMoving() && !this.animationDone && this.animationRequestId === 0) {\r\n            this.animation = this.prepareAnimation();\r\n            this.animationRequestId = window.requestAnimationFrame(this.animate);\r\n        }\r\n    }\r\n\r\n    componentWillUnmount() {\r\n        if (this.animationRequestId !== 0)\r\n            window.cancelAnimationFrame(this.animationRequestId);\r\n    }\r\n\r\n    animate(time) {\r\n        this.animation.update(time);\r\n\r\n        if (!this.animation.isCompleted())\r\n            this.animationRequestId = window.requestAnimationFrame(this.animate);\r\n        else {\r\n            this.animation = null;\r\n            this.animationDone = true;\r\n            this.animationRequestId = 0;\r\n            this.props.animationDoneCallback();\r\n        }\r\n    }\r\n\r\n    prepareAnimation() {\r\n        let totalAnimator = new SequentialAnimator();\r\n\r\n        // Translation\r\n        let xCellsDelta = this.props.cell.colDestination - this.props.cell.col;\r\n        let yCellsDelta = this.props.cell.rowDestination - this.props.cell.row;\r\n        let borderPx = Number.parseInt(getComputedStyle(this.divRef.current).getPropertyValue('--grid-border').trim().replace(\"px\", \"\"));\r\n        let boundingBox = this.divRef.current.getBoundingClientRect();\r\n        let cellWidth = boundingBox.width;\r\n        let cellHeight = boundingBox.height;\r\n        let xAxisMove = xCellsDelta !== 0;\r\n        let delta = xAxisMove ? (xCellsDelta * cellWidth) + (borderPx * xCellsDelta) : (yCellsDelta * cellHeight) + (borderPx * yCellsDelta);\r\n        let cellsDelta = xAxisMove ? xCellsDelta : yCellsDelta;\r\n        let translationDuration = Math.abs(cellsDelta) * ValueCell.TRANSLATION_1_CELL_DURATION;\r\n        let translationAnimator = new ValueAnimator(0, delta, translationDuration).setUpdatedValueCallback(val => {\r\n            let xVal = xCellsDelta !== 0 ? val : 0;\r\n            let yVal = yCellsDelta !== 0 ? val : 0;\r\n            this.setState({ translationX: xVal, translationY: yVal });\r\n        });\r\n        totalAnimator.addAnimator(translationAnimator);\r\n\r\n        // Merge animation, only if cell is merging\r\n        if (this.props.cell.isMergingInto()) {\r\n            let scaleAnimator = new ValueAnimator(100, 115, ValueCell.SCALING_DURATION, true).setUpdatedValueCallback(val => {\r\n                this.setState({ scaleFactor: val });\r\n            });\r\n            totalAnimator.addAnimator(scaleAnimator);\r\n        }\r\n\r\n        return totalAnimator;\r\n    }\r\n\r\n    resetAnimationStatus() {\r\n        this.animation = null;\r\n        this.animationDone = false;\r\n        this.animationRequestId = 0;\r\n    }\r\n}\r\n\r\nexport { ValueCell as default };","import React from 'react';\r\n\r\nclass BackgroundCell extends React.Component {\r\n    render() {\r\n        return (\r\n            <div className=\"bg-cell\" style={{ gridRow: this.props.row + 1, gridColumn: this.props.col + 1 }} />\r\n        );\r\n    }\r\n}\r\n\r\nexport { BackgroundCell as default };","function getRandomInt(max) {\r\n    return Math.floor(Math.random() * max);\r\n}\r\n\r\nexport { getRandomInt }\r\n","import { getRandomInt } from \"../utils/utils\";\r\n\r\nconst MoveDirection = {\r\n    UP: 0,\r\n    RIGHT: 1,\r\n    DOWN: 2,\r\n    LEFT: 3\r\n}\r\n\r\nconst GameStatus = {\r\n    WON: 0,\r\n    LOST: 1,\r\n    YET_UNDEFINED: 2\r\n}\r\n\r\nclass Cell {\r\n\r\n    static nextIdentifierAvailable = 1;\r\n\r\n    constructor(row, col, val = 0, nextVal = 0, rowDestination = null, colDestination = null, mergedInto = false, mergingInto=false, cellIdentifier = null) {\r\n        this.row = row;\r\n        this.col = col;\r\n        this.val = val;\r\n        this.nextVal = nextVal;\r\n        this.rowDestination = rowDestination;\r\n        this.colDestination = colDestination;\r\n        this.mergedInto = mergedInto;\r\n        this.mergingInto = mergingInto;\r\n        this.cellIdentifier = cellIdentifier || Cell.nextIdentifierAvailable++;\r\n    }\r\n\r\n    isEmpty() {\r\n        return this.val === 0;\r\n    }\r\n\r\n    applyMoveAndClear() {\r\n        if (this.isMoving()) {\r\n            this.row = this.rowDestination;\r\n            this.col = this.colDestination;\r\n            if (this.nextVal !== 0) {\r\n                this.val = this.nextVal;\r\n                this.nextVal = 0;\r\n            }\r\n            this.rowDestination = null;\r\n            this.colDestination = null;\r\n            this.mergingInto = false;\r\n            this.mergedInto = false;\r\n        }\r\n    }\r\n\r\n    moveBy(amount, direction) {\r\n        if (this.rowDestination === null)\r\n            this.rowDestination = this.row;\r\n        if (this.colDestination === null)\r\n            this.colDestination = this.col;\r\n\r\n        switch (direction) {\r\n            case MoveDirection.UP: this.rowDestination = this.rowDestination - amount; break;\r\n            case MoveDirection.DOWN: this.rowDestination = this.rowDestination + amount; break;\r\n            case MoveDirection.LEFT: this.colDestination = this.colDestination - amount; break;\r\n            case MoveDirection.RIGHT: this.colDestination = this.colDestination + amount; break;\r\n            default: return;\r\n        }\r\n    }\r\n\r\n    isMoving() {\r\n        return this.rowDestination !== null || this.colDestination !== null;\r\n    }\r\n\r\n    markGettingMerged() {\r\n        this.mergedInto = true;\r\n    }\r\n\r\n    markMerging() {\r\n        this.mergingInto = true;\r\n    }\r\n\r\n    isGettingMerged() {\r\n        return this.mergedInto;\r\n    }\r\n\r\n    isMergingInto() {\r\n        return this.mergingInto;\r\n    }\r\n\r\n    copy() {\r\n        return new Cell(this.row, this.col, this.val, this.nextVal, this.rowDestination, this.colDestination, this.mergedInto, this.mergingInto, this.cellIdentifier);\r\n    }\r\n}\r\n\r\nclass GameBoard {\r\n    constructor(rows, columns, cells) {\r\n        this.ROWS = rows;\r\n        this.COLUMNS = columns;\r\n        if (cells)\r\n            this.cells = cells;\r\n        else {\r\n            this.cells = Array(rows).fill().map(() => Array(columns).fill());\r\n            GameBoard.initializeGrid(this.cells, rows, columns);\r\n        }\r\n    }\r\n\r\n    copy() {\r\n        let cellsCopy = this.cells.map((row) => row.map(cell => cell.copy()));\r\n        return new GameBoard(this.ROWS, this.COLUMNS, cellsCopy);\r\n    }\r\n\r\n    static initializeGrid(cellsArray, rows, columns) {\r\n        for (let i = 0; i < rows; i++)\r\n            for (let j = 0; j < columns; j++)\r\n                cellsArray[i][j] = new Cell(i, j);\r\n\r\n        return cellsArray;\r\n    }\r\n\r\n    getNonEmptyCells() {\r\n        let nonEmptyCells = [];\r\n\r\n        this.cells.forEach(row => {\r\n            row.forEach(cell => {\r\n                if (!cell.isEmpty())\r\n                    nonEmptyCells.push(cell);\r\n            });\r\n        });\r\n\r\n        return nonEmptyCells;\r\n    }\r\n\r\n    /**\r\n     * \r\n     * @param {boolean} inPlace specify if doing the operation in place or return a new board with the pending moves applied\r\n     * @returns the board with the moves applied, or a copy of the board with the moves applied if inPlace=false\r\n     */\r\n\r\n    applyMoves(inPlace = false) {\r\n        let board = inPlace ? this : this.copy();\r\n\r\n        let flatCells = board.cells.flat();\r\n\r\n        GameBoard.initializeGrid(board.cells, board.ROWS, board.COLUMNS);\r\n\r\n        flatCells.forEach(cell => {\r\n            if (cell.isMoving()) {\r\n                if (!cell.isGettingMerged()) {\r\n                    board.cells[cell.rowDestination][cell.colDestination] = cell;\r\n                    cell.applyMoveAndClear();\r\n                }\r\n            } else {\r\n                if (!cell.isEmpty() && !cell.isGettingMerged())\r\n                    board.cells[cell.row][cell.col] = cell;\r\n            }\r\n        });\r\n\r\n        return board;\r\n    }\r\n\r\n\r\n    /**\r\n     * \r\n     * @param {number} n the number of cells to spawn\r\n     * @param {number} value the value of the cells spawned\r\n     * @param {boolean} inPlace specify if doing the operation in place or return a board copy with the spawned cells\r\n     * @returns the board ref itself or the new board with the spawned cells, the same board ref if it couldn't spawn any even if inPlace=false\r\n     */\r\n\r\n    spawnCells(n, value = 2, inPlace = false) {\r\n        let board = inPlace ? this : this.copy(); \r\n        let emptyCells = [];\r\n\r\n        board.cells.forEach(row => {\r\n            row.forEach(cell => {\r\n                if (cell.isEmpty())\r\n                    emptyCells.push(cell);\r\n            });\r\n        });\r\n\r\n\r\n        if (emptyCells.length < n)\r\n            return this;\r\n\r\n        for (let i = 0; i < n; i++) {\r\n            let cIndex = getRandomInt(emptyCells.length);\r\n            let emptyCell = emptyCells[cIndex];\r\n            board.cells[emptyCell.row][emptyCell.col].val = value;\r\n            emptyCells.splice(cIndex, 1);\r\n        }\r\n\r\n        return board;\r\n    }\r\n\r\n    /**\r\n     * \r\n     * @param {MoveDirection} moveDirection the direction you want the tiles to go\r\n     * @param {boolean} inPlace specify if doing the operation in place or return a board copy with the diffs applied\r\n     * @returns a new board with the tiles moved if any changes happened, otherwise the same board ref, even if inPlace=false\r\n     */\r\n\r\n    move(moveDirection, inPlace = false) {\r\n        let board = inPlace ? this : this.copy();\r\n        let lines = [];\r\n\r\n        switch (moveDirection) {\r\n            case MoveDirection.UP:\r\n                for (let col = 0; col < board.COLUMNS; col++) {\r\n                    let line = [];\r\n                    for (let row = 0; row < board.ROWS; row++)\r\n                        line.push(board.cells[row][col]);\r\n                    lines.push(line);\r\n                }\r\n                break;\r\n            case MoveDirection.DOWN:\r\n                for (let col = 0; col < board.COLUMNS; col++) {\r\n                    let line = [];\r\n                    for (let row = board.ROWS - 1; row >= 0; row--)\r\n                        line.push(board.cells[row][col]);\r\n                    lines.push(line);\r\n                }\r\n                break;\r\n            case MoveDirection.LEFT:\r\n                lines = board.cells.map(row => row.slice());\r\n                break;\r\n            case MoveDirection.RIGHT:\r\n                lines = board.cells.map(row => row.slice().reverse());\r\n                break;\r\n            default: return;\r\n        }\r\n\r\n        lines.forEach(line => {\r\n            let prevNonZeroCell = null;\r\n            for (let i = 0; i < line.length; i++) {\r\n                let cell = line[i];\r\n                if (cell.isEmpty()) {\r\n                    for (let j = i + 1; j < line.length; j++)\r\n                        if (!line[j].isEmpty())\r\n                            line[j].moveBy(1, moveDirection);\r\n                } else {\r\n                    if (prevNonZeroCell === null) {\r\n                        prevNonZeroCell = cell;\r\n                    } else {\r\n                        if (prevNonZeroCell.val === cell.val) {\r\n                            prevNonZeroCell.markGettingMerged();\r\n                            cell.nextVal = cell.val * 2;\r\n                            cell.markMerging();\r\n\r\n                            for (let j = i; j < line.length; j++) {\r\n                                if (!line[j].isEmpty())\r\n                                    line[j].moveBy(1, moveDirection);\r\n                            }\r\n\r\n                            prevNonZeroCell = null;\r\n                        } else {\r\n                            prevNonZeroCell = cell;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        });\r\n\r\n        let diffs = board.cells.flat().reduce((acc, cell) => acc + (cell.isMoving() ? 1 : 0), 0);\r\n\r\n        if (!diffs)\r\n            return this;\r\n\r\n        return board;\r\n    }\r\n\r\n    /**\r\n     * \r\n     * @param {number} winConditionThreshold the win condition magic number, 2048 normally\r\n     * @returns the current game status [GameStatus.WON, GameStatus.LOST, GameStatus.YET_UNDEFINED]\r\n     */\r\n\r\n    checkGameStatus(winConditionThreshold=2048) {\r\n        let cells = this.cells.flat();\r\n        \r\n        let hasWon = cells.some(cell => cell.val >= winConditionThreshold);\r\n        if(hasWon) \r\n            return GameStatus.WON;\r\n        \r\n        let possibleMoves = [MoveDirection.UP, MoveDirection.DOWN, MoveDirection.LEFT, MoveDirection.RIGHT];\r\n        let hasMoveAvailable = possibleMoves.some(move => this.move(move) !== this);\r\n        \r\n        if(hasMoveAvailable)\r\n            return GameStatus.YET_UNDEFINED;\r\n        else\r\n            return GameStatus.LOST;\r\n    }\r\n\r\n    /**\r\n     * @returns the score of the \"pending\" move, use before applyChanges, otherwise it'll return 0.\r\n     */\r\n\r\n    getMoveScore() {\r\n        return this.cells.flat().reduce((acc, cell) => acc + (cell.isMergingInto() ? cell.val * 2 : 0), 0);\r\n    }\r\n    \r\n    toString() {\r\n        return this.cells.map(row => row.map(cell => cell.val).join(' ')).join('\\r\\n');\r\n    }\r\n}\r\n\r\nexport { GameStatus, MoveDirection, Cell, GameBoard }","import React from 'react';\r\nimport ValueCell from './valuecell'\r\nimport BackgroundCell from './backgroundcell';\r\nimport { MoveDirection, GameBoard, GameStatus } from '../logic/gamelogic';\r\nimport { getRandomInt } from '../utils/utils';\r\n\r\nclass Board extends React.Component {\r\n    constructor(props) {\r\n        super(props);\r\n        this.handleKeyDown = this.handleKeyDown.bind(this);\r\n        this.handleAnimationDone = this.handleAnimationDone.bind(this);\r\n        this.reset = this.reset.bind(this);\r\n        this.state = this.reset(true);\r\n    }\r\n\r\n    reset(isConstructor = false) {\r\n        const gameBoard = new GameBoard(this.props.rows, this.props.columns).spawnCells(2, 2, true);\r\n        this.acceptInput = true;\r\n        this.expectedAnimations = -1;\r\n        this.autoMode = false;\r\n        this.autoModeToken = 'boom';\r\n        this.autoModeIndex = 0;\r\n        const state = {\r\n            board: gameBoard,\r\n            gameStatus: GameStatus.YET_UNDEFINED\r\n        }\r\n\r\n        if (!isConstructor)\r\n            this.setState(state);\r\n\r\n        return state;\r\n    }\r\n\r\n    generateBackgroundCells(rows, columns) {\r\n        let boxes = [];\r\n\r\n        for (let i = 0; i < rows; i++)\r\n            for (let j = 0; j < columns; j++)\r\n                boxes.push(<BackgroundCell key={i * columns + j} row={i} col={j} />);\r\n\r\n        return boxes;\r\n    }\r\n\r\n    handleAnimationDone() {\r\n        this.expectedAnimations -= 1;\r\n\r\n        if (this.expectedAnimations === 0) {\r\n            let newBoard = this.state.board.applyMoves().spawnCells(1, Math.random() < 0.9 ? 2 : 4, true);\r\n            let currentStatus = newBoard.checkGameStatus();\r\n\r\n            if (currentStatus === GameStatus.YET_UNDEFINED)\r\n                this.acceptInput = true;\r\n\r\n            this.props.onMoveDone(this.state.board.getMoveScore());\r\n\r\n            if (this.autoMode && currentStatus === GameStatus.YET_UNDEFINED)\r\n                this.setState({ board: newBoard, gameStatus: currentStatus }, this.autoPlay);\r\n            else\r\n                this.setState({ board: newBoard, gameStatus: currentStatus });\r\n        }\r\n    }\r\n\r\n    handleKeyDown(keyevent) {\r\n        if(this.autoMode)\r\n            this.autoMode = false;\r\n        if (!this.acceptInput)\r\n            return;\r\n\r\n        let oldBoard = this.state.board;\r\n        let newBoard;\r\n        let moveDir;\r\n\r\n        if (keyevent.key === this.autoModeToken[this.autoModeIndex]) {\r\n            this.autoModeIndex++;\r\n            if (this.autoModeIndex >= this.autoModeToken.length) {\r\n                this.autoMode = true;\r\n                this.autoPlay();\r\n                return;\r\n            }\r\n        } else {\r\n            this.autoModeIndex = 0;\r\n        }\r\n\r\n        switch (keyevent.keyCode) {\r\n            case 40: moveDir = MoveDirection.DOWN; break;\r\n            case 39: moveDir = MoveDirection.RIGHT; break;\r\n            case 38: moveDir = MoveDirection.UP; break;\r\n            case 37: moveDir = MoveDirection.LEFT; break;\r\n            default: return;\r\n        }\r\n\r\n        newBoard = oldBoard.move(moveDir, false);\r\n        if (newBoard !== oldBoard) {\r\n            this.acceptInput = false;\r\n            this.expectedAnimations = newBoard.cells.flat().reduce((acc, cell) => acc + (cell.isMoving() ? 1 : 0), 0);\r\n            this.setState({ board: newBoard });\r\n        }\r\n    }\r\n\r\n    autoPlay() {\r\n        setTimeout(() => {\r\n            if(!this.autoMode)\r\n                return;\r\n            const possibleMoves = [MoveDirection.UP, MoveDirection.DOWN, MoveDirection.LEFT, MoveDirection.RIGHT];\r\n            const currentBoard = this.state.board;\r\n            let nextBoard;\r\n\r\n            while(!nextBoard) {\r\n                let i = getRandomInt(possibleMoves.length);\r\n                let m = possibleMoves[i];\r\n                let nxt = currentBoard.move(m);\r\n                if(nxt !== currentBoard)\r\n                    nextBoard = nxt;\r\n                else\r\n                    possibleMoves.splice(i, 1);\r\n            }\r\n\r\n            this.acceptInput = false;\r\n            this.expectedAnimations = nextBoard.cells.flat().reduce((acc, cell) => acc + (cell.isMoving() ? 1 : 0), 0);\r\n            this.setState({ board: nextBoard });\r\n        }, 300);\r\n    }\r\n\r\n    componentDidMount() {\r\n        document.addEventListener(\"keydown\", this.handleKeyDown);\r\n        this.props.registerResetCallback(this.reset);\r\n    }\r\n\r\n    componentWillUnmount() {\r\n        document.removeEventListener(\"keydown\", this.handleKeyDown);\r\n    }\r\n\r\n    render() {\r\n        const bgCells = this.generateBackgroundCells(this.props.rows, this.props.columns);\r\n        const nonEmptyCells = this.state.board.getNonEmptyCells();\r\n        const valueCells = nonEmptyCells.map((c) => {\r\n            return <ValueCell key={c.cellIdentifier} cell={c} animationDoneCallback={this.handleAnimationDone} />\r\n        });\r\n        const gridOverlay = [];\r\n        if (this.state.gameStatus === GameStatus.WON)\r\n            gridOverlay.push(<div className=\"grid-overlay\">Gratz, you've won!</div>);\r\n        else if (this.state.gameStatus === GameStatus.LOST)\r\n            gridOverlay.push(<div className=\"grid-overlay\">You lost, will go better next time!</div>)\r\n\r\n        return (\r\n            <div className=\"gamegrid\" style={{ '--grid-rows': this.props.rows, '--grid-cols': this.props.columns }}>\r\n                {bgCells}\r\n                {valueCells}\r\n                {gridOverlay}\r\n            </div>\r\n        );\r\n    }\r\n}\r\n\r\nexport { Board as default };\r\n","class Storage {\r\n\r\n    constructor() {\r\n        if (localStorage === undefined) {\r\n            this.fallbackStorage = {};\r\n            this.supportsLocalStorage = false;\r\n        } else {\r\n            this.supportsLocalStorage = true;\r\n        }\r\n    }\r\n\r\n    getHighestScore(gridSize) {\r\n        const key = 'grid-' + gridSize.toString();\r\n        if (this.supportsLocalStorage) {\r\n            let score = localStorage.getItem(key);\r\n            if (!score)\r\n                return 0;\r\n            else\r\n                return Number.parseInt(score);\r\n        } else {\r\n            let score = this.fallbackStorage[key];\r\n            if (score === undefined)\r\n                return 0;\r\n            else\r\n                return score;\r\n        }\r\n    }\r\n\r\n    setHighestScore(gridSize, score) {\r\n        const key = 'grid-' + gridSize.toString();\r\n        if (this.supportsLocalStorage)\r\n            localStorage.setItem(key, score.toString());\r\n        else\r\n            this.fallbackStorage[key] = score;\r\n    }\r\n\r\n}\r\n\r\nexport { Storage as default }","import React from 'react';\r\nimport Board from './board';\r\nimport { Button, Dropdown, Ref } from 'semantic-ui-react';\r\nimport Storage from '../storage/storage';\r\n\r\nclass Header extends React.Component {\r\n    render() {\r\n        return (\r\n            <>\r\n                <div className=\"header-line-1\">\r\n                    <div className=\"game-title\">2048</div>\r\n                    <ScoreDisplay title=\"Current\" bgcolor=\"#21ba45\" value={this.props.currentScore} />\r\n                    <ScoreDisplay title=\"Top Score\" bgcolor=\"#2185d0\" value={this.props.topScore} />\r\n                </div>\r\n                <div className=\"header-line-2\">\r\n                    <div className=\"game-exp\">Use arrow keys to slide the tiles.</div>\r\n                    <GridSizeSelector options={this.props.options} onGridSizeChanged={this.props.onGridSizeChanged} defaultGridSize={this.props.defaultGridSize} />\r\n                    <NewGameButton onNewGameClicked={this.props.onNewGameClicked} />\r\n                </div>\r\n            </>\r\n        );\r\n    }\r\n}\r\n\r\nclass GridSizeSelector extends React.Component {\r\n    constructor(props) {\r\n        super(props);\r\n        this.onChange = this.onChange.bind(this);\r\n        this.myRef = React.createRef();\r\n    }\r\n\r\n    onChange(event, data) {\r\n        this.myRef.current.blur();\r\n        this.props.onGridSizeChanged(parseInt(data.value));\r\n    }\r\n\r\n    render() {\r\n        return (\r\n            <Ref innerRef={this.myRef}>\r\n                <Dropdown\r\n                    style={{margin: 0}}\r\n                    text='Grid Size'\r\n                    icon='grid layout'\r\n                    labeled\r\n                    floating\r\n                    button\r\n                    className='icon'\r\n                    options={this.props.options}\r\n                    defaultValue={this.props.defaultGridSize}\r\n                    onChange={this.onChange}\r\n                    closeOnBlur={true}\r\n                />\r\n            </Ref>\r\n        );\r\n    }\r\n}\r\n\r\nclass NewGameButton extends React.Component {\r\n    constructor(props) {\r\n        super(props);\r\n        this.onClick = this.onClick.bind(this);\r\n    }\r\n\r\n    onClick(event) {\r\n        event.target.blur();\r\n        this.props.onNewGameClicked();\r\n    }\r\n\r\n    render() {\r\n        return (\r\n            <Button style={{margin: 0}} color=\"teal\" onClick={this.onClick}>New Game</Button>\r\n        );\r\n    }\r\n}\r\n\r\nclass ScoreDisplay extends React.Component {\r\n    render() {\r\n        return (\r\n            <div style={{backgroundColor: this.props.bgcolor}} className=\"score-container\">\r\n                <div className=\"score-title\">\r\n                    {this.props.title}\r\n                </div>\r\n                <div className=\"score-value\">\r\n                    <p key={this.props.value}> \r\n                        {this.props.value} \r\n                    </p>\r\n                </div>\r\n            </div>\r\n        );\r\n    }\r\n}\r\n\r\nclass Game extends React.Component {\r\n\r\n    static DEFAULT_ROWS = 4;\r\n    static DEFAULT_COLS = 4;\r\n\r\n    constructor(props) {\r\n        super();\r\n        this.state = {\r\n            rows: Game.DEFAULT_ROWS,\r\n            columns: Game.DEFAULT_COLS,\r\n            currentScore: 0\r\n        };\r\n        this.gridOptions = []\r\n        for (let i = 4; i <= 8; i++)\r\n            this.gridOptions.push({ key: i, text: i.toString() + \" x \" + i.toString(), value: i });\r\n\r\n        this.handleGridResize = this.handleGridResize.bind(this);\r\n        this.handleNewGameClicked = this.handleNewGameClicked.bind(this);\r\n        this.setNewGameHandler = this.setNewGameHandler.bind(this);\r\n        this.handleMoveDone = this.handleMoveDone.bind(this);\r\n\r\n        this.storage = new Storage();\r\n    }\r\n\r\n    handleGridResize(newSize) {\r\n        this.setState({\r\n            rows: newSize,\r\n            columns: newSize,\r\n            currentScore: 0\r\n        });\r\n    }\r\n\r\n    setNewGameHandler(handler) {\r\n        this.newGameHandler = handler;\r\n    }\r\n\r\n    handleNewGameClicked() {\r\n        if (this.newGameHandler)\r\n            this.newGameHandler();\r\n        this.setState({currentScore: 0});\r\n    }\r\n\r\n    handleMoveDone(moveScore) {\r\n        console.log(moveScore);\r\n        console.log(this.state)\r\n        if(moveScore === 0)\r\n            return;\r\n        \r\n        const newScore = this.state.currentScore + moveScore;\r\n        const bestScore = this.storage.getHighestScore(this.state.rows);\r\n        if(newScore > bestScore)\r\n            this.storage.setHighestScore(this.state.rows, newScore);\r\n        this.setState({currentScore: newScore});\r\n    }\r\n\r\n    render() {\r\n        return (\r\n            <div className=\"gamecontainer\">\r\n                <Header \r\n                    options={this.gridOptions} \r\n                    defaultGridSize={this.gridOptions[0].value} \r\n                    onGridSizeChanged={this.handleGridResize} \r\n                    onNewGameClicked={this.handleNewGameClicked} \r\n                    currentScore={this.state.currentScore}\r\n                    topScore={this.storage.getHighestScore(this.state.rows)}\r\n                />\r\n                <Board \r\n                    key={this.state.rows * this.state.columns} \r\n                    rows={this.state.rows} columns={this.state.columns} \r\n                    registerResetCallback={this.setNewGameHandler} \r\n                    onMoveDone={this.handleMoveDone}\r\n                />\r\n                <div className=\"footer\">\r\n                    Game developed by Matteo Bernabito.<br/>\r\n                    Take a look at the source on my <a href=\"https://github.com/berna1995/my-2048\">Github</a>.\r\n                </div>\r\n            </div>\r\n        );\r\n    }\r\n}\r\n\r\nexport { Game as default };","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport Game from './components/game'\r\nimport 'semantic-ui-css/semantic.min.css'\r\nimport './css/index.css';\r\n\r\nReactDOM.render(\r\n    <Game/>,\r\n    document.getElementById('root')\r\n);"],"sourceRoot":""}